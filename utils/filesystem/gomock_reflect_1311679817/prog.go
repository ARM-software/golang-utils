// Code generated by MockGen. DO NOT EDIT.
package main

import (
	"encoding/gob"
	"flag"
	"fmt"
	"os"
	"path"
	"reflect"

	"go.uber.org/mock/mockgen/model"

	pkg_ "github.com/ARM-software/golang-utils/utils/filesystem"
)

var output = flag.String("output", "", "The output file name, or empty to use stdout.")

func main() {
	flag.Parse()

	its := []struct {
		sym string
		typ reflect.Type
	}{

		{"IFileHash", reflect.TypeOf((*pkg_.IFileHash)(nil)).Elem()},

		{"IChowner", reflect.TypeOf((*pkg_.IChowner)(nil)).Elem()},

		{"ILinker", reflect.TypeOf((*pkg_.ILinker)(nil)).Elem()},

		{"File", reflect.TypeOf((*pkg_.File)(nil)).Elem()},

		{"DiskUsage", reflect.TypeOf((*pkg_.DiskUsage)(nil)).Elem()},

		{"FileTimeInfo", reflect.TypeOf((*pkg_.FileTimeInfo)(nil)).Elem()},

		{"ILock", reflect.TypeOf((*pkg_.ILock)(nil)).Elem()},

		{"ILimits", reflect.TypeOf((*pkg_.ILimits)(nil)).Elem()},

		{"FS", reflect.TypeOf((*pkg_.FS)(nil)).Elem()},

		{"ICloseableFS", reflect.TypeOf((*pkg_.ICloseableFS)(nil)).Elem()},

		{"IForceRemover", reflect.TypeOf((*pkg_.IForceRemover)(nil)).Elem()},

		{"IStater", reflect.TypeOf((*pkg_.IStater)(nil)).Elem()},

		{"ILinkReader", reflect.TypeOf((*pkg_.ILinkReader)(nil)).Elem()},

		{"ISymLinker", reflect.TypeOf((*pkg_.ISymLinker)(nil)).Elem()},
	}
	pkg := &model.Package{
		// NOTE: This behaves contrary to documented behaviour if the
		// package name is not the final component of the import path.
		// The reflect package doesn't expose the package name, though.
		Name: path.Base("github.com/ARM-software/golang-utils/utils/filesystem"),
	}

	for _, it := range its {
		intf, err := model.InterfaceFromInterfaceType(it.typ)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Reflection: %v\n", err)
			os.Exit(1)
		}
		intf.Name = it.sym
		pkg.Interfaces = append(pkg.Interfaces, intf)
	}

	outfile := os.Stdout
	if len(*output) != 0 {
		var err error
		outfile, err = os.Create(*output)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to open output file %q", *output)
		}
		defer func() {
			if err := outfile.Close(); err != nil {
				fmt.Fprintf(os.Stderr, "failed to close output file %q", *output)
				os.Exit(1)
			}
		}()
	}

	if err := gob.NewEncoder(outfile).Encode(pkg); err != nil {
		fmt.Fprintf(os.Stderr, "gob encode: %v\n", err)
		os.Exit(1)
	}
}
