/*
 * Copyright (C) 2020-2022 Arm Limited or its affiliates and Contributors. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ARM-software/golang-utils/utils/logs (interfaces: Loggers,IMultipleLoggers,WriterWithSource,StdLogger)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	logr "github.com/go-logr/logr"
	gomock "github.com/golang/mock/gomock"

	logs "github.com/ARM-software/golang-utils/utils/logs"
)

// MockLoggers is a mock of Loggers interface.
type MockLoggers struct {
	ctrl     *gomock.Controller
	recorder *MockLoggersMockRecorder
}

// MockLoggersMockRecorder is the mock recorder for MockLoggers.
type MockLoggersMockRecorder struct {
	mock *MockLoggers
}

// NewMockLoggers creates a new mock instance.
func NewMockLoggers(ctrl *gomock.Controller) *MockLoggers {
	mock := &MockLoggers{ctrl: ctrl}
	mock.recorder = &MockLoggersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoggers) EXPECT() *MockLoggersMockRecorder {
	return m.recorder
}

// Check mocks base method.
func (m *MockLoggers) Check() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check")
	ret0, _ := ret[0].(error)
	return ret0
}

// Check indicates an expected call of Check.
func (mr *MockLoggersMockRecorder) Check() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockLoggers)(nil).Check))
}

// Close mocks base method.
func (m *MockLoggers) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLoggersMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLoggers)(nil).Close))
}

// Log mocks base method.
func (m *MockLoggers) Log(arg0 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockLoggersMockRecorder) Log(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLoggers)(nil).Log), arg0...)
}

// LogError mocks base method.
func (m *MockLoggers) LogError(arg0 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "LogError", varargs...)
}

// LogError indicates an expected call of LogError.
func (mr *MockLoggersMockRecorder) LogError(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogError", reflect.TypeOf((*MockLoggers)(nil).LogError), arg0...)
}

// SetLogSource mocks base method.
func (m *MockLoggers) SetLogSource(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLogSource", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLogSource indicates an expected call of SetLogSource.
func (mr *MockLoggersMockRecorder) SetLogSource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogSource", reflect.TypeOf((*MockLoggers)(nil).SetLogSource), arg0)
}

// SetLoggerSource mocks base method.
func (m *MockLoggers) SetLoggerSource(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLoggerSource", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLoggerSource indicates an expected call of SetLoggerSource.
func (mr *MockLoggersMockRecorder) SetLoggerSource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLoggerSource", reflect.TypeOf((*MockLoggers)(nil).SetLoggerSource), arg0)
}

// MockIMultipleLoggers is a mock of IMultipleLoggers interface.
type MockIMultipleLoggers struct {
	ctrl     *gomock.Controller
	recorder *MockIMultipleLoggersMockRecorder
}

// MockIMultipleLoggersMockRecorder is the mock recorder for MockIMultipleLoggers.
type MockIMultipleLoggersMockRecorder struct {
	mock *MockIMultipleLoggers
}

// NewMockIMultipleLoggers creates a new mock instance.
func NewMockIMultipleLoggers(ctrl *gomock.Controller) *MockIMultipleLoggers {
	mock := &MockIMultipleLoggers{ctrl: ctrl}
	mock.recorder = &MockIMultipleLoggersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMultipleLoggers) EXPECT() *MockIMultipleLoggersMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockIMultipleLoggers) Append(arg0 ...logs.Loggers) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Append", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockIMultipleLoggersMockRecorder) Append(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockIMultipleLoggers)(nil).Append), arg0...)
}

// AppendLogger mocks base method.
func (m *MockIMultipleLoggers) AppendLogger(arg0 ...logr.Logger) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendLogger", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AppendLogger indicates an expected call of AppendLogger.
func (mr *MockIMultipleLoggersMockRecorder) AppendLogger(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendLogger", reflect.TypeOf((*MockIMultipleLoggers)(nil).AppendLogger), arg0...)
}

// Check mocks base method.
func (m *MockIMultipleLoggers) Check() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check")
	ret0, _ := ret[0].(error)
	return ret0
}

// Check indicates an expected call of Check.
func (mr *MockIMultipleLoggersMockRecorder) Check() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockIMultipleLoggers)(nil).Check))
}

// Close mocks base method.
func (m *MockIMultipleLoggers) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIMultipleLoggersMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIMultipleLoggers)(nil).Close))
}

// Log mocks base method.
func (m *MockIMultipleLoggers) Log(arg0 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockIMultipleLoggersMockRecorder) Log(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockIMultipleLoggers)(nil).Log), arg0...)
}

// LogError mocks base method.
func (m *MockIMultipleLoggers) LogError(arg0 ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "LogError", varargs...)
}

// LogError indicates an expected call of LogError.
func (mr *MockIMultipleLoggersMockRecorder) LogError(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogError", reflect.TypeOf((*MockIMultipleLoggers)(nil).LogError), arg0...)
}

// SetLogSource mocks base method.
func (m *MockIMultipleLoggers) SetLogSource(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLogSource", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLogSource indicates an expected call of SetLogSource.
func (mr *MockIMultipleLoggersMockRecorder) SetLogSource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogSource", reflect.TypeOf((*MockIMultipleLoggers)(nil).SetLogSource), arg0)
}

// SetLoggerSource mocks base method.
func (m *MockIMultipleLoggers) SetLoggerSource(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLoggerSource", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLoggerSource indicates an expected call of SetLoggerSource.
func (mr *MockIMultipleLoggersMockRecorder) SetLoggerSource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLoggerSource", reflect.TypeOf((*MockIMultipleLoggers)(nil).SetLoggerSource), arg0)
}

// MockWriterWithSource is a mock of WriterWithSource interface.
type MockWriterWithSource struct {
	ctrl     *gomock.Controller
	recorder *MockWriterWithSourceMockRecorder
}

// MockWriterWithSourceMockRecorder is the mock recorder for MockWriterWithSource.
type MockWriterWithSourceMockRecorder struct {
	mock *MockWriterWithSource
}

// NewMockWriterWithSource creates a new mock instance.
func NewMockWriterWithSource(ctrl *gomock.Controller) *MockWriterWithSource {
	mock := &MockWriterWithSource{ctrl: ctrl}
	mock.recorder = &MockWriterWithSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriterWithSource) EXPECT() *MockWriterWithSourceMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockWriterWithSource) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockWriterWithSourceMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockWriterWithSource)(nil).Close))
}

// SetSource mocks base method.
func (m *MockWriterWithSource) SetSource(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSource", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetSource indicates an expected call of SetSource.
func (mr *MockWriterWithSourceMockRecorder) SetSource(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSource", reflect.TypeOf((*MockWriterWithSource)(nil).SetSource), arg0)
}

// Write mocks base method.
func (m *MockWriterWithSource) Write(arg0 []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockWriterWithSourceMockRecorder) Write(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockWriterWithSource)(nil).Write), arg0)
}

// MockStdLogger is a mock of StdLogger interface.
type MockStdLogger struct {
	ctrl     *gomock.Controller
	recorder *MockStdLoggerMockRecorder
}

// MockStdLoggerMockRecorder is the mock recorder for MockStdLogger.
type MockStdLoggerMockRecorder struct {
	mock *MockStdLogger
}

// NewMockStdLogger creates a new mock instance.
func NewMockStdLogger(ctrl *gomock.Controller) *MockStdLogger {
	mock := &MockStdLogger{ctrl: ctrl}
	mock.recorder = &MockStdLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStdLogger) EXPECT() *MockStdLoggerMockRecorder {
	return m.recorder
}

// Output mocks base method.
func (m *MockStdLogger) Output(arg0 int, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Output", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Output indicates an expected call of Output.
func (mr *MockStdLoggerMockRecorder) Output(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockStdLogger)(nil).Output), arg0, arg1)
}
