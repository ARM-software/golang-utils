// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ARM-software/golang-utils/utils/logs (interfaces: Loggers,IMultipleLoggers,WriterWithSource,StdLogger)
//
// Generated by this command:
//
//	mockgen -destination=../mocks/mock_logs.go -package=mocks github.com/ARM-software/golang-utils/utils/logs Loggers,IMultipleLoggers,WriterWithSource,StdLogger
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	logs "github.com/ARM-software/golang-utils/utils/logs"
	logr "github.com/go-logr/logr"
	gomock "go.uber.org/mock/gomock"
)

// MockLoggers is a mock of Loggers interface.
type MockLoggers struct {
	ctrl     *gomock.Controller
	recorder *MockLoggersMockRecorder
	isgomock struct{}
}

// MockLoggersMockRecorder is the mock recorder for MockLoggers.
type MockLoggersMockRecorder struct {
	mock *MockLoggers
}

// NewMockLoggers creates a new mock instance.
func NewMockLoggers(ctrl *gomock.Controller) *MockLoggers {
	mock := &MockLoggers{ctrl: ctrl}
	mock.recorder = &MockLoggersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLoggers) EXPECT() *MockLoggersMockRecorder {
	return m.recorder
}

// Check mocks base method.
func (m *MockLoggers) Check() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check")
	ret0, _ := ret[0].(error)
	return ret0
}

// Check indicates an expected call of Check.
func (mr *MockLoggersMockRecorder) Check() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockLoggers)(nil).Check))
}

// Close mocks base method.
func (m *MockLoggers) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLoggersMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLoggers)(nil).Close))
}

// Log mocks base method.
func (m *MockLoggers) Log(output ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range output {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockLoggersMockRecorder) Log(output ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLoggers)(nil).Log), output...)
}

// LogError mocks base method.
func (m *MockLoggers) LogError(err ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range err {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "LogError", varargs...)
}

// LogError indicates an expected call of LogError.
func (mr *MockLoggersMockRecorder) LogError(err ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogError", reflect.TypeOf((*MockLoggers)(nil).LogError), err...)
}

// SetLogSource mocks base method.
func (m *MockLoggers) SetLogSource(source string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLogSource", source)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLogSource indicates an expected call of SetLogSource.
func (mr *MockLoggersMockRecorder) SetLogSource(source any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogSource", reflect.TypeOf((*MockLoggers)(nil).SetLogSource), source)
}

// SetLoggerSource mocks base method.
func (m *MockLoggers) SetLoggerSource(source string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLoggerSource", source)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLoggerSource indicates an expected call of SetLoggerSource.
func (mr *MockLoggersMockRecorder) SetLoggerSource(source any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLoggerSource", reflect.TypeOf((*MockLoggers)(nil).SetLoggerSource), source)
}

// MockIMultipleLoggers is a mock of IMultipleLoggers interface.
type MockIMultipleLoggers struct {
	ctrl     *gomock.Controller
	recorder *MockIMultipleLoggersMockRecorder
	isgomock struct{}
}

// MockIMultipleLoggersMockRecorder is the mock recorder for MockIMultipleLoggers.
type MockIMultipleLoggersMockRecorder struct {
	mock *MockIMultipleLoggers
}

// NewMockIMultipleLoggers creates a new mock instance.
func NewMockIMultipleLoggers(ctrl *gomock.Controller) *MockIMultipleLoggers {
	mock := &MockIMultipleLoggers{ctrl: ctrl}
	mock.recorder = &MockIMultipleLoggersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMultipleLoggers) EXPECT() *MockIMultipleLoggersMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockIMultipleLoggers) Append(l ...logs.Loggers) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range l {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Append", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockIMultipleLoggersMockRecorder) Append(l ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockIMultipleLoggers)(nil).Append), l...)
}

// AppendLogger mocks base method.
func (m *MockIMultipleLoggers) AppendLogger(l ...logr.Logger) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range l {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendLogger", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// AppendLogger indicates an expected call of AppendLogger.
func (mr *MockIMultipleLoggersMockRecorder) AppendLogger(l ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendLogger", reflect.TypeOf((*MockIMultipleLoggers)(nil).AppendLogger), l...)
}

// Check mocks base method.
func (m *MockIMultipleLoggers) Check() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Check")
	ret0, _ := ret[0].(error)
	return ret0
}

// Check indicates an expected call of Check.
func (mr *MockIMultipleLoggersMockRecorder) Check() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockIMultipleLoggers)(nil).Check))
}

// Close mocks base method.
func (m *MockIMultipleLoggers) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIMultipleLoggersMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIMultipleLoggers)(nil).Close))
}

// Log mocks base method.
func (m *MockIMultipleLoggers) Log(output ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range output {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log.
func (mr *MockIMultipleLoggersMockRecorder) Log(output ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockIMultipleLoggers)(nil).Log), output...)
}

// LogError mocks base method.
func (m *MockIMultipleLoggers) LogError(err ...any) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range err {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "LogError", varargs...)
}

// LogError indicates an expected call of LogError.
func (mr *MockIMultipleLoggersMockRecorder) LogError(err ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogError", reflect.TypeOf((*MockIMultipleLoggers)(nil).LogError), err...)
}

// SetLogSource mocks base method.
func (m *MockIMultipleLoggers) SetLogSource(source string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLogSource", source)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLogSource indicates an expected call of SetLogSource.
func (mr *MockIMultipleLoggersMockRecorder) SetLogSource(source any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLogSource", reflect.TypeOf((*MockIMultipleLoggers)(nil).SetLogSource), source)
}

// SetLoggerSource mocks base method.
func (m *MockIMultipleLoggers) SetLoggerSource(source string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLoggerSource", source)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLoggerSource indicates an expected call of SetLoggerSource.
func (mr *MockIMultipleLoggersMockRecorder) SetLoggerSource(source any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLoggerSource", reflect.TypeOf((*MockIMultipleLoggers)(nil).SetLoggerSource), source)
}

// MockWriterWithSource is a mock of WriterWithSource interface.
type MockWriterWithSource struct {
	ctrl     *gomock.Controller
	recorder *MockWriterWithSourceMockRecorder
	isgomock struct{}
}

// MockWriterWithSourceMockRecorder is the mock recorder for MockWriterWithSource.
type MockWriterWithSourceMockRecorder struct {
	mock *MockWriterWithSource
}

// NewMockWriterWithSource creates a new mock instance.
func NewMockWriterWithSource(ctrl *gomock.Controller) *MockWriterWithSource {
	mock := &MockWriterWithSource{ctrl: ctrl}
	mock.recorder = &MockWriterWithSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriterWithSource) EXPECT() *MockWriterWithSourceMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockWriterWithSource) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockWriterWithSourceMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockWriterWithSource)(nil).Close))
}

// SetSource mocks base method.
func (m *MockWriterWithSource) SetSource(source string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSource", source)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetSource indicates an expected call of SetSource.
func (mr *MockWriterWithSourceMockRecorder) SetSource(source any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSource", reflect.TypeOf((*MockWriterWithSource)(nil).SetSource), source)
}

// Write mocks base method.
func (m *MockWriterWithSource) Write(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockWriterWithSourceMockRecorder) Write(p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockWriterWithSource)(nil).Write), p)
}

// MockStdLogger is a mock of StdLogger interface.
type MockStdLogger struct {
	ctrl     *gomock.Controller
	recorder *MockStdLoggerMockRecorder
	isgomock struct{}
}

// MockStdLoggerMockRecorder is the mock recorder for MockStdLogger.
type MockStdLoggerMockRecorder struct {
	mock *MockStdLogger
}

// NewMockStdLogger creates a new mock instance.
func NewMockStdLogger(ctrl *gomock.Controller) *MockStdLogger {
	mock := &MockStdLogger{ctrl: ctrl}
	mock.recorder = &MockStdLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStdLogger) EXPECT() *MockStdLoggerMockRecorder {
	return m.recorder
}

// Output mocks base method.
func (m *MockStdLogger) Output(calldepth int, logline string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Output", calldepth, logline)
	ret0, _ := ret[0].(error)
	return ret0
}

// Output indicates an expected call of Output.
func (mr *MockStdLoggerMockRecorder) Output(calldepth, logline any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockStdLogger)(nil).Output), calldepth, logline)
}
