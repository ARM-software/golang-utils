// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ARM-software/golang-utils/utils/filesystem (interfaces: IFileHash,IChowner,ILinker,File,DiskUsage,FileTimeInfo,ILock,ILimits,FS,ICloseableFS,IForceRemover,IStater,ILinkReader,ISymLinker)
//
// Generated by this command:
//
//	mockgen -destination=../mocks/mock_filesystem.go -package=mocks github.com/ARM-software/golang-utils/utils/filesystem IFileHash,IChowner,ILinker,File,DiskUsage,FileTimeInfo,ILock,ILimits,FS,ICloseableFS,IForceRemover,IStater,ILinkReader,ISymLinker
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	fs "io/fs"
	user "os/user"
	filepath "path/filepath"
	reflect "reflect"
	time "time"

	filesystem "github.com/ARM-software/golang-utils/utils/filesystem"
	v3 "github.com/bmatcuk/doublestar/v3"
	gomock "go.uber.org/mock/gomock"
)

// MockIFileHash is a mock of IFileHash interface.
type MockIFileHash struct {
	ctrl     *gomock.Controller
	recorder *MockIFileHashMockRecorder
	isgomock struct{}
}

// MockIFileHashMockRecorder is the mock recorder for MockIFileHash.
type MockIFileHashMockRecorder struct {
	mock *MockIFileHash
}

// NewMockIFileHash creates a new mock instance.
func NewMockIFileHash(ctrl *gomock.Controller) *MockIFileHash {
	mock := &MockIFileHash{ctrl: ctrl}
	mock.recorder = &MockIFileHashMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIFileHash) EXPECT() *MockIFileHashMockRecorder {
	return m.recorder
}

// Calculate mocks base method.
func (m *MockIFileHash) Calculate(f filesystem.File) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Calculate", f)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Calculate indicates an expected call of Calculate.
func (mr *MockIFileHashMockRecorder) Calculate(f any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Calculate", reflect.TypeOf((*MockIFileHash)(nil).Calculate), f)
}

// CalculateFile mocks base method.
func (m *MockIFileHash) CalculateFile(fs filesystem.FS, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateFile", fs, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateFile indicates an expected call of CalculateFile.
func (mr *MockIFileHashMockRecorder) CalculateFile(fs, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateFile", reflect.TypeOf((*MockIFileHash)(nil).CalculateFile), fs, path)
}

// CalculateFileWithContext mocks base method.
func (m *MockIFileHash) CalculateFileWithContext(ctx context.Context, fs filesystem.FS, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateFileWithContext", ctx, fs, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateFileWithContext indicates an expected call of CalculateFileWithContext.
func (mr *MockIFileHashMockRecorder) CalculateFileWithContext(ctx, fs, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateFileWithContext", reflect.TypeOf((*MockIFileHash)(nil).CalculateFileWithContext), ctx, fs, path)
}

// CalculateWithContext mocks base method.
func (m *MockIFileHash) CalculateWithContext(ctx context.Context, f filesystem.File) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateWithContext", ctx, f)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateWithContext indicates an expected call of CalculateWithContext.
func (mr *MockIFileHashMockRecorder) CalculateWithContext(ctx, f any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateWithContext", reflect.TypeOf((*MockIFileHash)(nil).CalculateWithContext), ctx, f)
}

// GetType mocks base method.
func (m *MockIFileHash) GetType() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockIFileHashMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockIFileHash)(nil).GetType))
}

// MockIChowner is a mock of IChowner interface.
type MockIChowner struct {
	ctrl     *gomock.Controller
	recorder *MockIChownerMockRecorder
	isgomock struct{}
}

// MockIChownerMockRecorder is the mock recorder for MockIChowner.
type MockIChownerMockRecorder struct {
	mock *MockIChowner
}

// NewMockIChowner creates a new mock instance.
func NewMockIChowner(ctrl *gomock.Controller) *MockIChowner {
	mock := &MockIChowner{ctrl: ctrl}
	mock.recorder = &MockIChownerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIChowner) EXPECT() *MockIChownerMockRecorder {
	return m.recorder
}

// ChownIfPossible mocks base method.
func (m *MockIChowner) ChownIfPossible(name string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownIfPossible", name, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownIfPossible indicates an expected call of ChownIfPossible.
func (mr *MockIChownerMockRecorder) ChownIfPossible(name, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownIfPossible", reflect.TypeOf((*MockIChowner)(nil).ChownIfPossible), name, uid, gid)
}

// MockILinker is a mock of ILinker interface.
type MockILinker struct {
	ctrl     *gomock.Controller
	recorder *MockILinkerMockRecorder
	isgomock struct{}
}

// MockILinkerMockRecorder is the mock recorder for MockILinker.
type MockILinkerMockRecorder struct {
	mock *MockILinker
}

// NewMockILinker creates a new mock instance.
func NewMockILinker(ctrl *gomock.Controller) *MockILinker {
	mock := &MockILinker{ctrl: ctrl}
	mock.recorder = &MockILinkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILinker) EXPECT() *MockILinkerMockRecorder {
	return m.recorder
}

// LinkIfPossible mocks base method.
func (m *MockILinker) LinkIfPossible(oldname, newname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LinkIfPossible", oldname, newname)
	ret0, _ := ret[0].(error)
	return ret0
}

// LinkIfPossible indicates an expected call of LinkIfPossible.
func (mr *MockILinkerMockRecorder) LinkIfPossible(oldname, newname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LinkIfPossible", reflect.TypeOf((*MockILinker)(nil).LinkIfPossible), oldname, newname)
}

// MockFile is a mock of File interface.
type MockFile struct {
	ctrl     *gomock.Controller
	recorder *MockFileMockRecorder
	isgomock struct{}
}

// MockFileMockRecorder is the mock recorder for MockFile.
type MockFileMockRecorder struct {
	mock *MockFile
}

// NewMockFile creates a new mock instance.
func NewMockFile(ctrl *gomock.Controller) *MockFile {
	mock := &MockFile{ctrl: ctrl}
	mock.recorder = &MockFileMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFile) EXPECT() *MockFileMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockFile) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockFileMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockFile)(nil).Close))
}

// Fd mocks base method.
func (m *MockFile) Fd() uintptr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fd")
	ret0, _ := ret[0].(uintptr)
	return ret0
}

// Fd indicates an expected call of Fd.
func (mr *MockFileMockRecorder) Fd() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fd", reflect.TypeOf((*MockFile)(nil).Fd))
}

// Name mocks base method.
func (m *MockFile) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockFileMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockFile)(nil).Name))
}

// Read mocks base method.
func (m *MockFile) Read(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockFileMockRecorder) Read(p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockFile)(nil).Read), p)
}

// ReadAt mocks base method.
func (m *MockFile) ReadAt(p []byte, off int64) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadAt", p, off)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadAt indicates an expected call of ReadAt.
func (mr *MockFileMockRecorder) ReadAt(p, off any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadAt", reflect.TypeOf((*MockFile)(nil).ReadAt), p, off)
}

// Readdir mocks base method.
func (m *MockFile) Readdir(count int) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readdir", count)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readdir indicates an expected call of Readdir.
func (mr *MockFileMockRecorder) Readdir(count any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readdir", reflect.TypeOf((*MockFile)(nil).Readdir), count)
}

// Readdirnames mocks base method.
func (m *MockFile) Readdirnames(n int) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readdirnames", n)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readdirnames indicates an expected call of Readdirnames.
func (mr *MockFileMockRecorder) Readdirnames(n any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readdirnames", reflect.TypeOf((*MockFile)(nil).Readdirnames), n)
}

// Seek mocks base method.
func (m *MockFile) Seek(offset int64, whence int) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Seek", offset, whence)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Seek indicates an expected call of Seek.
func (mr *MockFileMockRecorder) Seek(offset, whence any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seek", reflect.TypeOf((*MockFile)(nil).Seek), offset, whence)
}

// Stat mocks base method.
func (m *MockFile) Stat() (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat")
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFileMockRecorder) Stat() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFile)(nil).Stat))
}

// Sync mocks base method.
func (m *MockFile) Sync() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sync")
	ret0, _ := ret[0].(error)
	return ret0
}

// Sync indicates an expected call of Sync.
func (mr *MockFileMockRecorder) Sync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockFile)(nil).Sync))
}

// Truncate mocks base method.
func (m *MockFile) Truncate(size int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Truncate", size)
	ret0, _ := ret[0].(error)
	return ret0
}

// Truncate indicates an expected call of Truncate.
func (mr *MockFileMockRecorder) Truncate(size any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Truncate", reflect.TypeOf((*MockFile)(nil).Truncate), size)
}

// Write mocks base method.
func (m *MockFile) Write(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockFileMockRecorder) Write(p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockFile)(nil).Write), p)
}

// WriteAt mocks base method.
func (m *MockFile) WriteAt(p []byte, off int64) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteAt", p, off)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteAt indicates an expected call of WriteAt.
func (mr *MockFileMockRecorder) WriteAt(p, off any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteAt", reflect.TypeOf((*MockFile)(nil).WriteAt), p, off)
}

// WriteString mocks base method.
func (m *MockFile) WriteString(s string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteString", s)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteString indicates an expected call of WriteString.
func (mr *MockFileMockRecorder) WriteString(s any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteString", reflect.TypeOf((*MockFile)(nil).WriteString), s)
}

// MockDiskUsage is a mock of DiskUsage interface.
type MockDiskUsage struct {
	ctrl     *gomock.Controller
	recorder *MockDiskUsageMockRecorder
	isgomock struct{}
}

// MockDiskUsageMockRecorder is the mock recorder for MockDiskUsage.
type MockDiskUsageMockRecorder struct {
	mock *MockDiskUsage
}

// NewMockDiskUsage creates a new mock instance.
func NewMockDiskUsage(ctrl *gomock.Controller) *MockDiskUsage {
	mock := &MockDiskUsage{ctrl: ctrl}
	mock.recorder = &MockDiskUsageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDiskUsage) EXPECT() *MockDiskUsageMockRecorder {
	return m.recorder
}

// GetFree mocks base method.
func (m *MockDiskUsage) GetFree() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFree")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetFree indicates an expected call of GetFree.
func (mr *MockDiskUsageMockRecorder) GetFree() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFree", reflect.TypeOf((*MockDiskUsage)(nil).GetFree))
}

// GetInodesFree mocks base method.
func (m *MockDiskUsage) GetInodesFree() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesFree")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesFree indicates an expected call of GetInodesFree.
func (mr *MockDiskUsageMockRecorder) GetInodesFree() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesFree", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesFree))
}

// GetInodesTotal mocks base method.
func (m *MockDiskUsage) GetInodesTotal() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesTotal")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesTotal indicates an expected call of GetInodesTotal.
func (mr *MockDiskUsageMockRecorder) GetInodesTotal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesTotal", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesTotal))
}

// GetInodesUsed mocks base method.
func (m *MockDiskUsage) GetInodesUsed() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesUsed")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesUsed indicates an expected call of GetInodesUsed.
func (mr *MockDiskUsageMockRecorder) GetInodesUsed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesUsed", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesUsed))
}

// GetInodesUsedPercent mocks base method.
func (m *MockDiskUsage) GetInodesUsedPercent() float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesUsedPercent")
	ret0, _ := ret[0].(float64)
	return ret0
}

// GetInodesUsedPercent indicates an expected call of GetInodesUsedPercent.
func (mr *MockDiskUsageMockRecorder) GetInodesUsedPercent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesUsedPercent", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesUsedPercent))
}

// GetTotal mocks base method.
func (m *MockDiskUsage) GetTotal() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotal")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotal indicates an expected call of GetTotal.
func (mr *MockDiskUsageMockRecorder) GetTotal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotal", reflect.TypeOf((*MockDiskUsage)(nil).GetTotal))
}

// GetUsed mocks base method.
func (m *MockDiskUsage) GetUsed() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUsed")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetUsed indicates an expected call of GetUsed.
func (mr *MockDiskUsageMockRecorder) GetUsed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsed", reflect.TypeOf((*MockDiskUsage)(nil).GetUsed))
}

// GetUsedPercent mocks base method.
func (m *MockDiskUsage) GetUsedPercent() float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUsedPercent")
	ret0, _ := ret[0].(float64)
	return ret0
}

// GetUsedPercent indicates an expected call of GetUsedPercent.
func (mr *MockDiskUsageMockRecorder) GetUsedPercent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsedPercent", reflect.TypeOf((*MockDiskUsage)(nil).GetUsedPercent))
}

// MockFileTimeInfo is a mock of FileTimeInfo interface.
type MockFileTimeInfo struct {
	ctrl     *gomock.Controller
	recorder *MockFileTimeInfoMockRecorder
	isgomock struct{}
}

// MockFileTimeInfoMockRecorder is the mock recorder for MockFileTimeInfo.
type MockFileTimeInfoMockRecorder struct {
	mock *MockFileTimeInfo
}

// NewMockFileTimeInfo creates a new mock instance.
func NewMockFileTimeInfo(ctrl *gomock.Controller) *MockFileTimeInfo {
	mock := &MockFileTimeInfo{ctrl: ctrl}
	mock.recorder = &MockFileTimeInfoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileTimeInfo) EXPECT() *MockFileTimeInfoMockRecorder {
	return m.recorder
}

// AccessTime mocks base method.
func (m *MockFileTimeInfo) AccessTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AccessTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// AccessTime indicates an expected call of AccessTime.
func (mr *MockFileTimeInfoMockRecorder) AccessTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AccessTime", reflect.TypeOf((*MockFileTimeInfo)(nil).AccessTime))
}

// BirthTime mocks base method.
func (m *MockFileTimeInfo) BirthTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BirthTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// BirthTime indicates an expected call of BirthTime.
func (mr *MockFileTimeInfoMockRecorder) BirthTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BirthTime", reflect.TypeOf((*MockFileTimeInfo)(nil).BirthTime))
}

// ChangeTime mocks base method.
func (m *MockFileTimeInfo) ChangeTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// ChangeTime indicates an expected call of ChangeTime.
func (mr *MockFileTimeInfoMockRecorder) ChangeTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeTime", reflect.TypeOf((*MockFileTimeInfo)(nil).ChangeTime))
}

// HasAccessTime mocks base method.
func (m *MockFileTimeInfo) HasAccessTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasAccessTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasAccessTime indicates an expected call of HasAccessTime.
func (mr *MockFileTimeInfoMockRecorder) HasAccessTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasAccessTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasAccessTime))
}

// HasBirthTime mocks base method.
func (m *MockFileTimeInfo) HasBirthTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasBirthTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasBirthTime indicates an expected call of HasBirthTime.
func (mr *MockFileTimeInfoMockRecorder) HasBirthTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasBirthTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasBirthTime))
}

// HasChangeTime mocks base method.
func (m *MockFileTimeInfo) HasChangeTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasChangeTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasChangeTime indicates an expected call of HasChangeTime.
func (mr *MockFileTimeInfoMockRecorder) HasChangeTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasChangeTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasChangeTime))
}

// ModTime mocks base method.
func (m *MockFileTimeInfo) ModTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// ModTime indicates an expected call of ModTime.
func (mr *MockFileTimeInfoMockRecorder) ModTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModTime", reflect.TypeOf((*MockFileTimeInfo)(nil).ModTime))
}

// MockILock is a mock of ILock interface.
type MockILock struct {
	ctrl     *gomock.Controller
	recorder *MockILockMockRecorder
	isgomock struct{}
}

// MockILockMockRecorder is the mock recorder for MockILock.
type MockILockMockRecorder struct {
	mock *MockILock
}

// NewMockILock creates a new mock instance.
func NewMockILock(ctrl *gomock.Controller) *MockILock {
	mock := &MockILock{ctrl: ctrl}
	mock.recorder = &MockILockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILock) EXPECT() *MockILockMockRecorder {
	return m.recorder
}

// IsStale mocks base method.
func (m *MockILock) IsStale() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStale")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStale indicates an expected call of IsStale.
func (mr *MockILockMockRecorder) IsStale() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStale", reflect.TypeOf((*MockILock)(nil).IsStale))
}

// Lock mocks base method.
func (m *MockILock) Lock(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Lock indicates an expected call of Lock.
func (mr *MockILockMockRecorder) Lock(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockILock)(nil).Lock), ctx)
}

// LockWithTimeout mocks base method.
func (m *MockILock) LockWithTimeout(ctx context.Context, timeout time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockWithTimeout", ctx, timeout)
	ret0, _ := ret[0].(error)
	return ret0
}

// LockWithTimeout indicates an expected call of LockWithTimeout.
func (mr *MockILockMockRecorder) LockWithTimeout(ctx, timeout any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockWithTimeout", reflect.TypeOf((*MockILock)(nil).LockWithTimeout), ctx, timeout)
}

// MakeStale mocks base method.
func (m *MockILock) MakeStale(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MakeStale", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// MakeStale indicates an expected call of MakeStale.
func (mr *MockILockMockRecorder) MakeStale(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeStale", reflect.TypeOf((*MockILock)(nil).MakeStale), ctx)
}

// ReleaseIfStale mocks base method.
func (m *MockILock) ReleaseIfStale(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReleaseIfStale", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReleaseIfStale indicates an expected call of ReleaseIfStale.
func (mr *MockILockMockRecorder) ReleaseIfStale(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseIfStale", reflect.TypeOf((*MockILock)(nil).ReleaseIfStale), ctx)
}

// TryLock mocks base method.
func (m *MockILock) TryLock(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryLock", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// TryLock indicates an expected call of TryLock.
func (mr *MockILockMockRecorder) TryLock(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryLock", reflect.TypeOf((*MockILock)(nil).TryLock), ctx)
}

// Unlock mocks base method.
func (m *MockILock) Unlock(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlock", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlock indicates an expected call of Unlock.
func (mr *MockILockMockRecorder) Unlock(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*MockILock)(nil).Unlock), ctx)
}

// MockILimits is a mock of ILimits interface.
type MockILimits struct {
	ctrl     *gomock.Controller
	recorder *MockILimitsMockRecorder
	isgomock struct{}
}

// MockILimitsMockRecorder is the mock recorder for MockILimits.
type MockILimitsMockRecorder struct {
	mock *MockILimits
}

// NewMockILimits creates a new mock instance.
func NewMockILimits(ctrl *gomock.Controller) *MockILimits {
	mock := &MockILimits{ctrl: ctrl}
	mock.recorder = &MockILimitsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILimits) EXPECT() *MockILimitsMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockILimits) Apply() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockILimitsMockRecorder) Apply() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockILimits)(nil).Apply))
}

// ApplyRecursively mocks base method.
func (m *MockILimits) ApplyRecursively() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyRecursively")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ApplyRecursively indicates an expected call of ApplyRecursively.
func (mr *MockILimitsMockRecorder) ApplyRecursively() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyRecursively", reflect.TypeOf((*MockILimits)(nil).ApplyRecursively))
}

// GetMaxDepth mocks base method.
func (m *MockILimits) GetMaxDepth() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxDepth")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxDepth indicates an expected call of GetMaxDepth.
func (mr *MockILimitsMockRecorder) GetMaxDepth() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxDepth", reflect.TypeOf((*MockILimits)(nil).GetMaxDepth))
}

// GetMaxFileCount mocks base method.
func (m *MockILimits) GetMaxFileCount() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxFileCount")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxFileCount indicates an expected call of GetMaxFileCount.
func (mr *MockILimitsMockRecorder) GetMaxFileCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxFileCount", reflect.TypeOf((*MockILimits)(nil).GetMaxFileCount))
}

// GetMaxFileSize mocks base method.
func (m *MockILimits) GetMaxFileSize() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxFileSize")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxFileSize indicates an expected call of GetMaxFileSize.
func (mr *MockILimitsMockRecorder) GetMaxFileSize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxFileSize", reflect.TypeOf((*MockILimits)(nil).GetMaxFileSize))
}

// GetMaxTotalSize mocks base method.
func (m *MockILimits) GetMaxTotalSize() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxTotalSize")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetMaxTotalSize indicates an expected call of GetMaxTotalSize.
func (mr *MockILimitsMockRecorder) GetMaxTotalSize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxTotalSize", reflect.TypeOf((*MockILimits)(nil).GetMaxTotalSize))
}

// Validate mocks base method.
func (m *MockILimits) Validate() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate")
	ret0, _ := ret[0].(error)
	return ret0
}

// Validate indicates an expected call of Validate.
func (mr *MockILimitsMockRecorder) Validate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockILimits)(nil).Validate))
}

// MockFS is a mock of FS interface.
type MockFS struct {
	ctrl     *gomock.Controller
	recorder *MockFSMockRecorder
	isgomock struct{}
}

// MockFSMockRecorder is the mock recorder for MockFS.
type MockFSMockRecorder struct {
	mock *MockFS
}

// NewMockFS creates a new mock instance.
func NewMockFS(ctrl *gomock.Controller) *MockFS {
	mock := &MockFS{ctrl: ctrl}
	mock.recorder = &MockFSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFS) EXPECT() *MockFSMockRecorder {
	return m.recorder
}

// ChangeOwnership mocks base method.
func (m *MockFS) ChangeOwnership(name string, owner *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnership", name, owner)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnership indicates an expected call of ChangeOwnership.
func (mr *MockFSMockRecorder) ChangeOwnership(name, owner any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnership", reflect.TypeOf((*MockFS)(nil).ChangeOwnership), name, owner)
}

// ChangeOwnershipRecursively mocks base method.
func (m *MockFS) ChangeOwnershipRecursively(ctx context.Context, path string, owner *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnershipRecursively", ctx, path, owner)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnershipRecursively indicates an expected call of ChangeOwnershipRecursively.
func (mr *MockFSMockRecorder) ChangeOwnershipRecursively(ctx, path, owner any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnershipRecursively", reflect.TypeOf((*MockFS)(nil).ChangeOwnershipRecursively), ctx, path, owner)
}

// Chmod mocks base method.
func (m *MockFS) Chmod(name string, mode fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", name, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockFSMockRecorder) Chmod(name, mode any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockFS)(nil).Chmod), name, mode)
}

// ChmodRecursively mocks base method.
func (m *MockFS) ChmodRecursively(ctx context.Context, path string, mode fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChmodRecursively", ctx, path, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChmodRecursively indicates an expected call of ChmodRecursively.
func (mr *MockFSMockRecorder) ChmodRecursively(ctx, path, mode any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChmodRecursively", reflect.TypeOf((*MockFS)(nil).ChmodRecursively), ctx, path, mode)
}

// Chown mocks base method.
func (m *MockFS) Chown(name string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", name, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockFSMockRecorder) Chown(name, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockFS)(nil).Chown), name, uid, gid)
}

// ChownRecursively mocks base method.
func (m *MockFS) ChownRecursively(ctx context.Context, path string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownRecursively", ctx, path, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownRecursively indicates an expected call of ChownRecursively.
func (mr *MockFSMockRecorder) ChownRecursively(ctx, path, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownRecursively", reflect.TypeOf((*MockFS)(nil).ChownRecursively), ctx, path, uid, gid)
}

// Chtimes mocks base method.
func (m *MockFS) Chtimes(name string, atime, mtime time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chtimes", name, atime, mtime)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chtimes indicates an expected call of Chtimes.
func (mr *MockFSMockRecorder) Chtimes(name, atime, mtime any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chtimes", reflect.TypeOf((*MockFS)(nil).Chtimes), name, atime, mtime)
}

// CleanDir mocks base method.
func (m *MockFS) CleanDir(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDir", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDir indicates an expected call of CleanDir.
func (mr *MockFSMockRecorder) CleanDir(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDir", reflect.TypeOf((*MockFS)(nil).CleanDir), dir)
}

// CleanDirWithContext mocks base method.
func (m *MockFS) CleanDirWithContext(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDirWithContext", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContext indicates an expected call of CleanDirWithContext.
func (mr *MockFSMockRecorder) CleanDirWithContext(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContext", reflect.TypeOf((*MockFS)(nil).CleanDirWithContext), ctx, dir)
}

// CleanDirWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) CleanDirWithContextAndExclusionPatterns(ctx context.Context, dir string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CleanDirWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContextAndExclusionPatterns indicates an expected call of CleanDirWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) CleanDirWithContextAndExclusionPatterns(ctx, dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).CleanDirWithContextAndExclusionPatterns), varargs...)
}

// ConvertFilePath mocks base method.
func (m *MockFS) ConvertFilePath(name string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConvertFilePath", name)
	ret0, _ := ret[0].(string)
	return ret0
}

// ConvertFilePath indicates an expected call of ConvertFilePath.
func (mr *MockFSMockRecorder) ConvertFilePath(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFilePath", reflect.TypeOf((*MockFS)(nil).ConvertFilePath), name)
}

// ConvertToAbsolutePath mocks base method.
func (m *MockFS) ConvertToAbsolutePath(rootPath string, paths ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{rootPath}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToAbsolutePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToAbsolutePath indicates an expected call of ConvertToAbsolutePath.
func (mr *MockFSMockRecorder) ConvertToAbsolutePath(rootPath any, paths ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rootPath}, paths...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToAbsolutePath", reflect.TypeOf((*MockFS)(nil).ConvertToAbsolutePath), varargs...)
}

// ConvertToRelativePath mocks base method.
func (m *MockFS) ConvertToRelativePath(rootPath string, paths ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{rootPath}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToRelativePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToRelativePath indicates an expected call of ConvertToRelativePath.
func (mr *MockFSMockRecorder) ConvertToRelativePath(rootPath any, paths ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rootPath}, paths...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToRelativePath", reflect.TypeOf((*MockFS)(nil).ConvertToRelativePath), varargs...)
}

// Copy mocks base method.
func (m *MockFS) Copy(src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockFSMockRecorder) Copy(src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockFS)(nil).Copy), src, dest)
}

// CopyToDirectory mocks base method.
func (m *MockFS) CopyToDirectory(src, destDirectory string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectory", src, destDirectory)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectory indicates an expected call of CopyToDirectory.
func (mr *MockFSMockRecorder) CopyToDirectory(src, destDirectory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectory", reflect.TypeOf((*MockFS)(nil).CopyToDirectory), src, destDirectory)
}

// CopyToDirectoryWithContext mocks base method.
func (m *MockFS) CopyToDirectoryWithContext(ctx context.Context, src, destDirectory string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectoryWithContext", ctx, src, destDirectory)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectoryWithContext indicates an expected call of CopyToDirectoryWithContext.
func (mr *MockFSMockRecorder) CopyToDirectoryWithContext(ctx, src, destDirectory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectoryWithContext", reflect.TypeOf((*MockFS)(nil).CopyToDirectoryWithContext), ctx, src, destDirectory)
}

// CopyToFile mocks base method.
func (m *MockFS) CopyToFile(srcFile, destFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFile", srcFile, destFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFile indicates an expected call of CopyToFile.
func (mr *MockFSMockRecorder) CopyToFile(srcFile, destFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFile", reflect.TypeOf((*MockFS)(nil).CopyToFile), srcFile, destFile)
}

// CopyToFileWithContext mocks base method.
func (m *MockFS) CopyToFileWithContext(ctx context.Context, srcFile, destFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFileWithContext", ctx, srcFile, destFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFileWithContext indicates an expected call of CopyToFileWithContext.
func (mr *MockFSMockRecorder) CopyToFileWithContext(ctx, srcFile, destFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFileWithContext", reflect.TypeOf((*MockFS)(nil).CopyToFileWithContext), ctx, srcFile, destFile)
}

// CopyWithContext mocks base method.
func (m *MockFS) CopyWithContext(ctx context.Context, src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyWithContext", ctx, src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContext indicates an expected call of CopyWithContext.
func (mr *MockFSMockRecorder) CopyWithContext(ctx, src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContext", reflect.TypeOf((*MockFS)(nil).CopyWithContext), ctx, src, dest)
}

// CopyWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) CopyWithContextAndExclusionPatterns(ctx context.Context, src, dest string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, src, dest}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContextAndExclusionPatterns indicates an expected call of CopyWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) CopyWithContextAndExclusionPatterns(ctx, src, dest any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, src, dest}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).CopyWithContextAndExclusionPatterns), varargs...)
}

// CreateFile mocks base method.
func (m *MockFS) CreateFile(name string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateFile", name)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateFile indicates an expected call of CreateFile.
func (mr *MockFSMockRecorder) CreateFile(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateFile", reflect.TypeOf((*MockFS)(nil).CreateFile), name)
}

// CurrentDirectory mocks base method.
func (m *MockFS) CurrentDirectory() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentDirectory")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentDirectory indicates an expected call of CurrentDirectory.
func (mr *MockFSMockRecorder) CurrentDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentDirectory", reflect.TypeOf((*MockFS)(nil).CurrentDirectory))
}

// DiskUsage mocks base method.
func (m *MockFS) DiskUsage(name string) (filesystem.DiskUsage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiskUsage", name)
	ret0, _ := ret[0].(filesystem.DiskUsage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiskUsage indicates an expected call of DiskUsage.
func (mr *MockFSMockRecorder) DiskUsage(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskUsage", reflect.TypeOf((*MockFS)(nil).DiskUsage), name)
}

// ExcludeAll mocks base method.
func (m *MockFS) ExcludeAll(files []string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{files}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExcludeAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExcludeAll indicates an expected call of ExcludeAll.
func (mr *MockFSMockRecorder) ExcludeAll(files any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{files}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExcludeAll", reflect.TypeOf((*MockFS)(nil).ExcludeAll), varargs...)
}

// Exists mocks base method.
func (m *MockFS) Exists(path string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", path)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockFSMockRecorder) Exists(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockFS)(nil).Exists), path)
}

// FetchFileOwner mocks base method.
func (m *MockFS) FetchFileOwner(name string) (*user.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchFileOwner", name)
	ret0, _ := ret[0].(*user.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchFileOwner indicates an expected call of FetchFileOwner.
func (mr *MockFSMockRecorder) FetchFileOwner(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchFileOwner", reflect.TypeOf((*MockFS)(nil).FetchFileOwner), name)
}

// FetchOwners mocks base method.
func (m *MockFS) FetchOwners(name string) (int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOwners", name)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchOwners indicates an expected call of FetchOwners.
func (mr *MockFSMockRecorder) FetchOwners(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOwners", reflect.TypeOf((*MockFS)(nil).FetchOwners), name)
}

// FileHash mocks base method.
func (m *MockFS) FileHash(hashAlgo, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHash", hashAlgo, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHash indicates an expected call of FileHash.
func (mr *MockFSMockRecorder) FileHash(hashAlgo, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHash", reflect.TypeOf((*MockFS)(nil).FileHash), hashAlgo, path)
}

// FileHashWithContext mocks base method.
func (m *MockFS) FileHashWithContext(ctx context.Context, hashAlgo, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHashWithContext", ctx, hashAlgo, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHashWithContext indicates an expected call of FileHashWithContext.
func (mr *MockFSMockRecorder) FileHashWithContext(ctx, hashAlgo, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHashWithContext", reflect.TypeOf((*MockFS)(nil).FileHashWithContext), ctx, hashAlgo, path)
}

// FindAll mocks base method.
func (m *MockFS) FindAll(dir string, extensions ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{dir}
	for _, a := range extensions {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockFSMockRecorder) FindAll(dir any, extensions ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{dir}, extensions...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockFS)(nil).FindAll), varargs...)
}

// GarbageCollect mocks base method.
func (m *MockFS) GarbageCollect(root string, durationSinceLastAccess time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollect", root, durationSinceLastAccess)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollect indicates an expected call of GarbageCollect.
func (mr *MockFSMockRecorder) GarbageCollect(root, durationSinceLastAccess any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollect", reflect.TypeOf((*MockFS)(nil).GarbageCollect), root, durationSinceLastAccess)
}

// GarbageCollectWithContext mocks base method.
func (m *MockFS) GarbageCollectWithContext(ctx context.Context, root string, durationSinceLastAccess time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollectWithContext", ctx, root, durationSinceLastAccess)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollectWithContext indicates an expected call of GarbageCollectWithContext.
func (mr *MockFSMockRecorder) GarbageCollectWithContext(ctx, root, durationSinceLastAccess any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollectWithContext", reflect.TypeOf((*MockFS)(nil).GarbageCollectWithContext), ctx, root, durationSinceLastAccess)
}

// GenericOpen mocks base method.
func (m *MockFS) GenericOpen(name string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenericOpen", name)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenericOpen indicates an expected call of GenericOpen.
func (mr *MockFSMockRecorder) GenericOpen(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenericOpen", reflect.TypeOf((*MockFS)(nil).GenericOpen), name)
}

// GetFileSize mocks base method.
func (m *MockFS) GetFileSize(filename string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFileSize", filename)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFileSize indicates an expected call of GetFileSize.
func (mr *MockFSMockRecorder) GetFileSize(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileSize", reflect.TypeOf((*MockFS)(nil).GetFileSize), filename)
}

// GetType mocks base method.
func (m *MockFS) GetType() filesystem.FilesystemType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(filesystem.FilesystemType)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockFSMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockFS)(nil).GetType))
}

// Glob mocks base method.
func (m *MockFS) Glob(pattern string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Glob", pattern)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Glob indicates an expected call of Glob.
func (mr *MockFSMockRecorder) Glob(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Glob", reflect.TypeOf((*MockFS)(nil).Glob), pattern)
}

// IsDir mocks base method.
func (m *MockFS) IsDir(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDir indicates an expected call of IsDir.
func (mr *MockFSMockRecorder) IsDir(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockFS)(nil).IsDir), path)
}

// IsEmpty mocks base method.
func (m *MockFS) IsEmpty(name string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", name)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockFSMockRecorder) IsEmpty(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockFS)(nil).IsEmpty), name)
}

// IsFile mocks base method.
func (m *MockFS) IsFile(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFile", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsFile indicates an expected call of IsFile.
func (mr *MockFSMockRecorder) IsFile(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFile", reflect.TypeOf((*MockFS)(nil).IsFile), path)
}

// IsLink mocks base method.
func (m *MockFS) IsLink(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLink", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLink indicates an expected call of IsLink.
func (mr *MockFSMockRecorder) IsLink(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLink", reflect.TypeOf((*MockFS)(nil).IsLink), path)
}

// IsZip mocks base method.
func (m *MockFS) IsZip(filepath string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZip", filepath)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsZip indicates an expected call of IsZip.
func (mr *MockFSMockRecorder) IsZip(filepath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZip", reflect.TypeOf((*MockFS)(nil).IsZip), filepath)
}

// IsZipWithContext mocks base method.
func (m *MockFS) IsZipWithContext(ctx context.Context, filepath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZipWithContext", ctx, filepath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsZipWithContext indicates an expected call of IsZipWithContext.
func (mr *MockFSMockRecorder) IsZipWithContext(ctx, filepath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZipWithContext", reflect.TypeOf((*MockFS)(nil).IsZipWithContext), ctx, filepath)
}

// Link mocks base method.
func (m *MockFS) Link(oldname, newname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Link", oldname, newname)
	ret0, _ := ret[0].(error)
	return ret0
}

// Link indicates an expected call of Link.
func (mr *MockFSMockRecorder) Link(oldname, newname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Link", reflect.TypeOf((*MockFS)(nil).Link), oldname, newname)
}

// ListDirTree mocks base method.
func (m *MockFS) ListDirTree(dirPath string, list *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTree", dirPath, list)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTree indicates an expected call of ListDirTree.
func (mr *MockFSMockRecorder) ListDirTree(dirPath, list any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTree", reflect.TypeOf((*MockFS)(nil).ListDirTree), dirPath, list)
}

// ListDirTreeWithContext mocks base method.
func (m *MockFS) ListDirTreeWithContext(ctx context.Context, dirPath string, list *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTreeWithContext", ctx, dirPath, list)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContext indicates an expected call of ListDirTreeWithContext.
func (mr *MockFSMockRecorder) ListDirTreeWithContext(ctx, dirPath, list any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContext", reflect.TypeOf((*MockFS)(nil).ListDirTreeWithContext), ctx, dirPath, list)
}

// ListDirTreeWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) ListDirTreeWithContextAndExclusionPatterns(ctx context.Context, dirPath string, list *[]string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dirPath, list}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDirTreeWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContextAndExclusionPatterns indicates an expected call of ListDirTreeWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) ListDirTreeWithContextAndExclusionPatterns(ctx, dirPath, list any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dirPath, list}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).ListDirTreeWithContextAndExclusionPatterns), varargs...)
}

// Lls mocks base method.
func (m *MockFS) Lls(dir string) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lls", dir)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lls indicates an expected call of Lls.
func (mr *MockFSMockRecorder) Lls(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lls", reflect.TypeOf((*MockFS)(nil).Lls), dir)
}

// LlsFromOpenedDirectory mocks base method.
func (m *MockFS) LlsFromOpenedDirectory(dir filesystem.File) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LlsFromOpenedDirectory", dir)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LlsFromOpenedDirectory indicates an expected call of LlsFromOpenedDirectory.
func (mr *MockFSMockRecorder) LlsFromOpenedDirectory(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LlsFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LlsFromOpenedDirectory), dir)
}

// Ls mocks base method.
func (m *MockFS) Ls(dir string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ls", dir)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ls indicates an expected call of Ls.
func (mr *MockFSMockRecorder) Ls(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ls", reflect.TypeOf((*MockFS)(nil).Ls), dir)
}

// LsFromOpenedDirectory mocks base method.
func (m *MockFS) LsFromOpenedDirectory(dir filesystem.File) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsFromOpenedDirectory", dir)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsFromOpenedDirectory indicates an expected call of LsFromOpenedDirectory.
func (mr *MockFSMockRecorder) LsFromOpenedDirectory(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LsFromOpenedDirectory), dir)
}

// LsRecursive mocks base method.
func (m *MockFS) LsRecursive(ctx context.Context, dir string, includeDirectories bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursive", ctx, dir, includeDirectories)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursive indicates an expected call of LsRecursive.
func (mr *MockFSMockRecorder) LsRecursive(ctx, dir, includeDirectories any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursive", reflect.TypeOf((*MockFS)(nil).LsRecursive), ctx, dir, includeDirectories)
}

// LsRecursiveFromOpenedDirectory mocks base method.
func (m *MockFS) LsRecursiveFromOpenedDirectory(ctx context.Context, dir filesystem.File, includeDirectories bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursiveFromOpenedDirectory", ctx, dir, includeDirectories)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveFromOpenedDirectory indicates an expected call of LsRecursiveFromOpenedDirectory.
func (mr *MockFSMockRecorder) LsRecursiveFromOpenedDirectory(ctx, dir, includeDirectories any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LsRecursiveFromOpenedDirectory), ctx, dir, includeDirectories)
}

// LsRecursiveWithExclusionPatterns mocks base method.
func (m *MockFS) LsRecursiveWithExclusionPatterns(ctx context.Context, dir string, includeDirectories bool, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir, includeDirectories}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatterns indicates an expected call of LsRecursiveWithExclusionPatterns.
func (mr *MockFSMockRecorder) LsRecursiveWithExclusionPatterns(ctx, dir, includeDirectories any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir, includeDirectories}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatterns", reflect.TypeOf((*MockFS)(nil).LsRecursiveWithExclusionPatterns), varargs...)
}

// LsRecursiveWithExclusionPatternsAndLimits mocks base method.
func (m *MockFS) LsRecursiveWithExclusionPatternsAndLimits(ctx context.Context, dir string, limit filesystem.ILimits, includeDirectories bool, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir, limit, includeDirectories}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatternsAndLimits", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatternsAndLimits indicates an expected call of LsRecursiveWithExclusionPatternsAndLimits.
func (mr *MockFSMockRecorder) LsRecursiveWithExclusionPatternsAndLimits(ctx, dir, limit, includeDirectories any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir, limit, includeDirectories}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatternsAndLimits", reflect.TypeOf((*MockFS)(nil).LsRecursiveWithExclusionPatternsAndLimits), varargs...)
}

// LsWithExclusionPatterns mocks base method.
func (m *MockFS) LsWithExclusionPatterns(dir string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsWithExclusionPatterns indicates an expected call of LsWithExclusionPatterns.
func (mr *MockFSMockRecorder) LsWithExclusionPatterns(dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsWithExclusionPatterns", reflect.TypeOf((*MockFS)(nil).LsWithExclusionPatterns), varargs...)
}

// Lstat mocks base method.
func (m *MockFS) Lstat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockFSMockRecorder) Lstat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockFS)(nil).Lstat), name)
}

// MkDir mocks base method.
func (m *MockFS) MkDir(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDir", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDir indicates an expected call of MkDir.
func (mr *MockFSMockRecorder) MkDir(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDir", reflect.TypeOf((*MockFS)(nil).MkDir), dir)
}

// MkDirAll mocks base method.
func (m *MockFS) MkDirAll(dir string, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDirAll", dir, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDirAll indicates an expected call of MkDirAll.
func (mr *MockFSMockRecorder) MkDirAll(dir, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDirAll", reflect.TypeOf((*MockFS)(nil).MkDirAll), dir, perm)
}

// Move mocks base method.
func (m *MockFS) Move(src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Move", src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Move indicates an expected call of Move.
func (mr *MockFSMockRecorder) Move(src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Move", reflect.TypeOf((*MockFS)(nil).Move), src, dest)
}

// MoveWithContext mocks base method.
func (m *MockFS) MoveWithContext(ctx context.Context, src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveWithContext", ctx, src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveWithContext indicates an expected call of MoveWithContext.
func (mr *MockFSMockRecorder) MoveWithContext(ctx, src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveWithContext", reflect.TypeOf((*MockFS)(nil).MoveWithContext), ctx, src, dest)
}

// NewRemoteLockFile mocks base method.
func (m *MockFS) NewRemoteLockFile(id, dirToLock string) filesystem.ILock {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewRemoteLockFile", id, dirToLock)
	ret0, _ := ret[0].(filesystem.ILock)
	return ret0
}

// NewRemoteLockFile indicates an expected call of NewRemoteLockFile.
func (mr *MockFSMockRecorder) NewRemoteLockFile(id, dirToLock any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewRemoteLockFile", reflect.TypeOf((*MockFS)(nil).NewRemoteLockFile), id, dirToLock)
}

// Open mocks base method.
func (m *MockFS) Open(name string) (v3.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", name)
	ret0, _ := ret[0].(v3.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockFSMockRecorder) Open(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockFS)(nil).Open), name)
}

// OpenFile mocks base method.
func (m *MockFS) OpenFile(name string, flag int, perm fs.FileMode) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", name, flag, perm)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockFSMockRecorder) OpenFile(name, flag, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockFS)(nil).OpenFile), name, flag, perm)
}

// PathSeparator mocks base method.
func (m *MockFS) PathSeparator() rune {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathSeparator")
	ret0, _ := ret[0].(rune)
	return ret0
}

// PathSeparator indicates an expected call of PathSeparator.
func (mr *MockFSMockRecorder) PathSeparator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathSeparator", reflect.TypeOf((*MockFS)(nil).PathSeparator))
}

// ReadFile mocks base method.
func (m *MockFS) ReadFile(filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockFSMockRecorder) ReadFile(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockFS)(nil).ReadFile), filename)
}

// ReadFileContent mocks base method.
func (m *MockFS) ReadFileContent(ctx context.Context, file filesystem.File, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileContent", ctx, file, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileContent indicates an expected call of ReadFileContent.
func (mr *MockFSMockRecorder) ReadFileContent(ctx, file, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileContent", reflect.TypeOf((*MockFS)(nil).ReadFileContent), ctx, file, limits)
}

// ReadFileWithContext mocks base method.
func (m *MockFS) ReadFileWithContext(ctx context.Context, filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContext", ctx, filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContext indicates an expected call of ReadFileWithContext.
func (mr *MockFSMockRecorder) ReadFileWithContext(ctx, filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContext", reflect.TypeOf((*MockFS)(nil).ReadFileWithContext), ctx, filename)
}

// ReadFileWithContextAndLimits mocks base method.
func (m *MockFS) ReadFileWithContextAndLimits(ctx context.Context, filename string, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContextAndLimits", ctx, filename, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContextAndLimits indicates an expected call of ReadFileWithContextAndLimits.
func (mr *MockFSMockRecorder) ReadFileWithContextAndLimits(ctx, filename, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).ReadFileWithContextAndLimits), ctx, filename, limits)
}

// ReadFileWithLimits mocks base method.
func (m *MockFS) ReadFileWithLimits(filename string, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithLimits", filename, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithLimits indicates an expected call of ReadFileWithLimits.
func (mr *MockFSMockRecorder) ReadFileWithLimits(filename, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithLimits", reflect.TypeOf((*MockFS)(nil).ReadFileWithLimits), filename, limits)
}

// Readlink mocks base method.
func (m *MockFS) Readlink(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockFSMockRecorder) Readlink(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockFS)(nil).Readlink), name)
}

// RemoveWithContext mocks base method.
func (m *MockFS) RemoveWithContext(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithContext", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContext indicates an expected call of RemoveWithContext.
func (mr *MockFSMockRecorder) RemoveWithContext(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContext", reflect.TypeOf((*MockFS)(nil).RemoveWithContext), ctx, dir)
}

// RemoveWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) RemoveWithContextAndExclusionPatterns(ctx context.Context, dir string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContextAndExclusionPatterns indicates an expected call of RemoveWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) RemoveWithContextAndExclusionPatterns(ctx, dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).RemoveWithContextAndExclusionPatterns), varargs...)
}

// RemoveWithPrivileges mocks base method.
func (m *MockFS) RemoveWithPrivileges(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithPrivileges", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithPrivileges indicates an expected call of RemoveWithPrivileges.
func (mr *MockFSMockRecorder) RemoveWithPrivileges(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithPrivileges", reflect.TypeOf((*MockFS)(nil).RemoveWithPrivileges), ctx, dir)
}

// Rm mocks base method.
func (m *MockFS) Rm(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rm", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rm indicates an expected call of Rm.
func (mr *MockFSMockRecorder) Rm(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rm", reflect.TypeOf((*MockFS)(nil).Rm), dir)
}

// Stat mocks base method.
func (m *MockFS) Stat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFSMockRecorder) Stat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFS)(nil).Stat), name)
}

// StatTimes mocks base method.
func (m *MockFS) StatTimes(name string) (filesystem.FileTimeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatTimes", name)
	ret0, _ := ret[0].(filesystem.FileTimeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatTimes indicates an expected call of StatTimes.
func (mr *MockFSMockRecorder) StatTimes(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatTimes", reflect.TypeOf((*MockFS)(nil).StatTimes), name)
}

// SubDirectories mocks base method.
func (m *MockFS) SubDirectories(directory string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectories", directory)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectories indicates an expected call of SubDirectories.
func (mr *MockFSMockRecorder) SubDirectories(directory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectories", reflect.TypeOf((*MockFS)(nil).SubDirectories), directory)
}

// SubDirectoriesWithContext mocks base method.
func (m *MockFS) SubDirectoriesWithContext(ctx context.Context, directory string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectoriesWithContext", ctx, directory)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContext indicates an expected call of SubDirectoriesWithContext.
func (mr *MockFSMockRecorder) SubDirectoriesWithContext(ctx, directory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContext", reflect.TypeOf((*MockFS)(nil).SubDirectoriesWithContext), ctx, directory)
}

// SubDirectoriesWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) SubDirectoriesWithContextAndExclusionPatterns(ctx context.Context, directory string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, directory}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubDirectoriesWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContextAndExclusionPatterns indicates an expected call of SubDirectoriesWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) SubDirectoriesWithContextAndExclusionPatterns(ctx, directory any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, directory}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).SubDirectoriesWithContextAndExclusionPatterns), varargs...)
}

// Symlink mocks base method.
func (m *MockFS) Symlink(oldname, newname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Symlink", oldname, newname)
	ret0, _ := ret[0].(error)
	return ret0
}

// Symlink indicates an expected call of Symlink.
func (mr *MockFSMockRecorder) Symlink(oldname, newname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Symlink", reflect.TypeOf((*MockFS)(nil).Symlink), oldname, newname)
}

// TempDir mocks base method.
func (m *MockFS) TempDir(dir, prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDir", dir, prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDir indicates an expected call of TempDir.
func (mr *MockFSMockRecorder) TempDir(dir, prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDir", reflect.TypeOf((*MockFS)(nil).TempDir), dir, prefix)
}

// TempDirInTempDir mocks base method.
func (m *MockFS) TempDirInTempDir(prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirInTempDir", prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDirInTempDir indicates an expected call of TempDirInTempDir.
func (mr *MockFSMockRecorder) TempDirInTempDir(prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirInTempDir", reflect.TypeOf((*MockFS)(nil).TempDirInTempDir), prefix)
}

// TempDirectory mocks base method.
func (m *MockFS) TempDirectory() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirectory")
	ret0, _ := ret[0].(string)
	return ret0
}

// TempDirectory indicates an expected call of TempDirectory.
func (mr *MockFSMockRecorder) TempDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirectory", reflect.TypeOf((*MockFS)(nil).TempDirectory))
}

// TempFile mocks base method.
func (m *MockFS) TempFile(dir, pattern string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFile", dir, pattern)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFile indicates an expected call of TempFile.
func (mr *MockFSMockRecorder) TempFile(dir, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFile", reflect.TypeOf((*MockFS)(nil).TempFile), dir, pattern)
}

// TempFileInTempDir mocks base method.
func (m *MockFS) TempFileInTempDir(pattern string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFileInTempDir", pattern)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFileInTempDir indicates an expected call of TempFileInTempDir.
func (mr *MockFSMockRecorder) TempFileInTempDir(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFileInTempDir", reflect.TypeOf((*MockFS)(nil).TempFileInTempDir), pattern)
}

// Touch mocks base method.
func (m *MockFS) Touch(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Touch", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// Touch indicates an expected call of Touch.
func (mr *MockFSMockRecorder) Touch(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockFS)(nil).Touch), path)
}

// TouchTempFile mocks base method.
func (m *MockFS) TouchTempFile(dir, pattern string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFile", dir, pattern)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFile indicates an expected call of TouchTempFile.
func (mr *MockFSMockRecorder) TouchTempFile(dir, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFile", reflect.TypeOf((*MockFS)(nil).TouchTempFile), dir, pattern)
}

// TouchTempFileInTempDir mocks base method.
func (m *MockFS) TouchTempFileInTempDir(pattern string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFileInTempDir", pattern)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFileInTempDir indicates an expected call of TouchTempFileInTempDir.
func (mr *MockFSMockRecorder) TouchTempFileInTempDir(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFileInTempDir", reflect.TypeOf((*MockFS)(nil).TouchTempFileInTempDir), pattern)
}

// Unzip mocks base method.
func (m *MockFS) Unzip(source, destination string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unzip", source, destination)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unzip indicates an expected call of Unzip.
func (mr *MockFSMockRecorder) Unzip(source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unzip", reflect.TypeOf((*MockFS)(nil).Unzip), source, destination)
}

// UnzipWithContext mocks base method.
func (m *MockFS) UnzipWithContext(ctx context.Context, source, destination string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContext", ctx, source, destination)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContext indicates an expected call of UnzipWithContext.
func (mr *MockFSMockRecorder) UnzipWithContext(ctx, source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContext", reflect.TypeOf((*MockFS)(nil).UnzipWithContext), ctx, source, destination)
}

// UnzipWithContextAndLimits mocks base method.
func (m *MockFS) UnzipWithContextAndLimits(ctx context.Context, source, destination string, limits filesystem.ILimits) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContextAndLimits", ctx, source, destination, limits)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContextAndLimits indicates an expected call of UnzipWithContextAndLimits.
func (mr *MockFSMockRecorder) UnzipWithContextAndLimits(ctx, source, destination, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).UnzipWithContextAndLimits), ctx, source, destination, limits)
}

// Walk mocks base method.
func (m *MockFS) Walk(root string, fn filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockFSMockRecorder) Walk(root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockFS)(nil).Walk), root, fn)
}

// WalkWithContext mocks base method.
func (m *MockFS) WalkWithContext(ctx context.Context, root string, fn filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkWithContext", ctx, root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContext indicates an expected call of WalkWithContext.
func (mr *MockFSMockRecorder) WalkWithContext(ctx, root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContext", reflect.TypeOf((*MockFS)(nil).WalkWithContext), ctx, root, fn)
}

// WalkWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) WalkWithContextAndExclusionPatterns(ctx context.Context, root string, fn filepath.WalkFunc, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, root, fn}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalkWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContextAndExclusionPatterns indicates an expected call of WalkWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) WalkWithContextAndExclusionPatterns(ctx, root, fn any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, root, fn}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).WalkWithContextAndExclusionPatterns), varargs...)
}

// WriteFile mocks base method.
func (m *MockFS) WriteFile(filename string, data []byte, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", filename, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockFSMockRecorder) WriteFile(filename, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockFS)(nil).WriteFile), filename, data, perm)
}

// WriteFileWithContext mocks base method.
func (m *MockFS) WriteFileWithContext(ctx context.Context, filename string, data []byte, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFileWithContext", ctx, filename, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFileWithContext indicates an expected call of WriteFileWithContext.
func (mr *MockFSMockRecorder) WriteFileWithContext(ctx, filename, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFileWithContext", reflect.TypeOf((*MockFS)(nil).WriteFileWithContext), ctx, filename, data, perm)
}

// WriteToFile mocks base method.
func (m *MockFS) WriteToFile(ctx context.Context, filename string, reader io.Reader, perm fs.FileMode) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteToFile", ctx, filename, reader, perm)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteToFile indicates an expected call of WriteToFile.
func (mr *MockFSMockRecorder) WriteToFile(ctx, filename, reader, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteToFile", reflect.TypeOf((*MockFS)(nil).WriteToFile), ctx, filename, reader, perm)
}

// Zip mocks base method.
func (m *MockFS) Zip(source, destination string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Zip", source, destination)
	ret0, _ := ret[0].(error)
	return ret0
}

// Zip indicates an expected call of Zip.
func (mr *MockFSMockRecorder) Zip(source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Zip", reflect.TypeOf((*MockFS)(nil).Zip), source, destination)
}

// ZipWithContext mocks base method.
func (m *MockFS) ZipWithContext(ctx context.Context, source, destination string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContext", ctx, source, destination)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContext indicates an expected call of ZipWithContext.
func (mr *MockFSMockRecorder) ZipWithContext(ctx, source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContext", reflect.TypeOf((*MockFS)(nil).ZipWithContext), ctx, source, destination)
}

// ZipWithContextAndLimits mocks base method.
func (m *MockFS) ZipWithContextAndLimits(ctx context.Context, source, destination string, limits filesystem.ILimits) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContextAndLimits", ctx, source, destination, limits)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimits indicates an expected call of ZipWithContextAndLimits.
func (mr *MockFSMockRecorder) ZipWithContextAndLimits(ctx, source, destination, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).ZipWithContextAndLimits), ctx, source, destination, limits)
}

// ZipWithContextAndLimitsAndExclusionPatterns mocks base method.
func (m *MockFS) ZipWithContextAndLimitsAndExclusionPatterns(ctx context.Context, source, destination string, limits filesystem.ILimits, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, source, destination, limits}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZipWithContextAndLimitsAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimitsAndExclusionPatterns indicates an expected call of ZipWithContextAndLimitsAndExclusionPatterns.
func (mr *MockFSMockRecorder) ZipWithContextAndLimitsAndExclusionPatterns(ctx, source, destination, limits any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, source, destination, limits}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimitsAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).ZipWithContextAndLimitsAndExclusionPatterns), varargs...)
}

// MockICloseableFS is a mock of ICloseableFS interface.
type MockICloseableFS struct {
	ctrl     *gomock.Controller
	recorder *MockICloseableFSMockRecorder
	isgomock struct{}
}

// MockICloseableFSMockRecorder is the mock recorder for MockICloseableFS.
type MockICloseableFSMockRecorder struct {
	mock *MockICloseableFS
}

// NewMockICloseableFS creates a new mock instance.
func NewMockICloseableFS(ctrl *gomock.Controller) *MockICloseableFS {
	mock := &MockICloseableFS{ctrl: ctrl}
	mock.recorder = &MockICloseableFSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICloseableFS) EXPECT() *MockICloseableFSMockRecorder {
	return m.recorder
}

// ChangeOwnership mocks base method.
func (m *MockICloseableFS) ChangeOwnership(name string, owner *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnership", name, owner)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnership indicates an expected call of ChangeOwnership.
func (mr *MockICloseableFSMockRecorder) ChangeOwnership(name, owner any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnership", reflect.TypeOf((*MockICloseableFS)(nil).ChangeOwnership), name, owner)
}

// ChangeOwnershipRecursively mocks base method.
func (m *MockICloseableFS) ChangeOwnershipRecursively(ctx context.Context, path string, owner *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnershipRecursively", ctx, path, owner)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnershipRecursively indicates an expected call of ChangeOwnershipRecursively.
func (mr *MockICloseableFSMockRecorder) ChangeOwnershipRecursively(ctx, path, owner any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnershipRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChangeOwnershipRecursively), ctx, path, owner)
}

// Chmod mocks base method.
func (m *MockICloseableFS) Chmod(name string, mode fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", name, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockICloseableFSMockRecorder) Chmod(name, mode any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockICloseableFS)(nil).Chmod), name, mode)
}

// ChmodRecursively mocks base method.
func (m *MockICloseableFS) ChmodRecursively(ctx context.Context, path string, mode fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChmodRecursively", ctx, path, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChmodRecursively indicates an expected call of ChmodRecursively.
func (mr *MockICloseableFSMockRecorder) ChmodRecursively(ctx, path, mode any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChmodRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChmodRecursively), ctx, path, mode)
}

// Chown mocks base method.
func (m *MockICloseableFS) Chown(name string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", name, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockICloseableFSMockRecorder) Chown(name, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockICloseableFS)(nil).Chown), name, uid, gid)
}

// ChownRecursively mocks base method.
func (m *MockICloseableFS) ChownRecursively(ctx context.Context, path string, uid, gid int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownRecursively", ctx, path, uid, gid)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownRecursively indicates an expected call of ChownRecursively.
func (mr *MockICloseableFSMockRecorder) ChownRecursively(ctx, path, uid, gid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChownRecursively), ctx, path, uid, gid)
}

// Chtimes mocks base method.
func (m *MockICloseableFS) Chtimes(name string, atime, mtime time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chtimes", name, atime, mtime)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chtimes indicates an expected call of Chtimes.
func (mr *MockICloseableFSMockRecorder) Chtimes(name, atime, mtime any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chtimes", reflect.TypeOf((*MockICloseableFS)(nil).Chtimes), name, atime, mtime)
}

// CleanDir mocks base method.
func (m *MockICloseableFS) CleanDir(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDir", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDir indicates an expected call of CleanDir.
func (mr *MockICloseableFSMockRecorder) CleanDir(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDir", reflect.TypeOf((*MockICloseableFS)(nil).CleanDir), dir)
}

// CleanDirWithContext mocks base method.
func (m *MockICloseableFS) CleanDirWithContext(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDirWithContext", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContext indicates an expected call of CleanDirWithContext.
func (mr *MockICloseableFSMockRecorder) CleanDirWithContext(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CleanDirWithContext), ctx, dir)
}

// CleanDirWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) CleanDirWithContextAndExclusionPatterns(ctx context.Context, dir string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CleanDirWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContextAndExclusionPatterns indicates an expected call of CleanDirWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) CleanDirWithContextAndExclusionPatterns(ctx, dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).CleanDirWithContextAndExclusionPatterns), varargs...)
}

// Close mocks base method.
func (m *MockICloseableFS) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockICloseableFSMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockICloseableFS)(nil).Close))
}

// ConvertFilePath mocks base method.
func (m *MockICloseableFS) ConvertFilePath(name string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConvertFilePath", name)
	ret0, _ := ret[0].(string)
	return ret0
}

// ConvertFilePath indicates an expected call of ConvertFilePath.
func (mr *MockICloseableFSMockRecorder) ConvertFilePath(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFilePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertFilePath), name)
}

// ConvertToAbsolutePath mocks base method.
func (m *MockICloseableFS) ConvertToAbsolutePath(rootPath string, paths ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{rootPath}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToAbsolutePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToAbsolutePath indicates an expected call of ConvertToAbsolutePath.
func (mr *MockICloseableFSMockRecorder) ConvertToAbsolutePath(rootPath any, paths ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rootPath}, paths...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToAbsolutePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertToAbsolutePath), varargs...)
}

// ConvertToRelativePath mocks base method.
func (m *MockICloseableFS) ConvertToRelativePath(rootPath string, paths ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{rootPath}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToRelativePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToRelativePath indicates an expected call of ConvertToRelativePath.
func (mr *MockICloseableFSMockRecorder) ConvertToRelativePath(rootPath any, paths ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rootPath}, paths...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToRelativePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertToRelativePath), varargs...)
}

// Copy mocks base method.
func (m *MockICloseableFS) Copy(src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockICloseableFSMockRecorder) Copy(src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockICloseableFS)(nil).Copy), src, dest)
}

// CopyToDirectory mocks base method.
func (m *MockICloseableFS) CopyToDirectory(src, destDirectory string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectory", src, destDirectory)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectory indicates an expected call of CopyToDirectory.
func (mr *MockICloseableFSMockRecorder) CopyToDirectory(src, destDirectory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectory", reflect.TypeOf((*MockICloseableFS)(nil).CopyToDirectory), src, destDirectory)
}

// CopyToDirectoryWithContext mocks base method.
func (m *MockICloseableFS) CopyToDirectoryWithContext(ctx context.Context, src, destDirectory string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectoryWithContext", ctx, src, destDirectory)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectoryWithContext indicates an expected call of CopyToDirectoryWithContext.
func (mr *MockICloseableFSMockRecorder) CopyToDirectoryWithContext(ctx, src, destDirectory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectoryWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyToDirectoryWithContext), ctx, src, destDirectory)
}

// CopyToFile mocks base method.
func (m *MockICloseableFS) CopyToFile(srcFile, destFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFile", srcFile, destFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFile indicates an expected call of CopyToFile.
func (mr *MockICloseableFSMockRecorder) CopyToFile(srcFile, destFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFile", reflect.TypeOf((*MockICloseableFS)(nil).CopyToFile), srcFile, destFile)
}

// CopyToFileWithContext mocks base method.
func (m *MockICloseableFS) CopyToFileWithContext(ctx context.Context, srcFile, destFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFileWithContext", ctx, srcFile, destFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFileWithContext indicates an expected call of CopyToFileWithContext.
func (mr *MockICloseableFSMockRecorder) CopyToFileWithContext(ctx, srcFile, destFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyToFileWithContext), ctx, srcFile, destFile)
}

// CopyWithContext mocks base method.
func (m *MockICloseableFS) CopyWithContext(ctx context.Context, src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyWithContext", ctx, src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContext indicates an expected call of CopyWithContext.
func (mr *MockICloseableFSMockRecorder) CopyWithContext(ctx, src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyWithContext), ctx, src, dest)
}

// CopyWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) CopyWithContextAndExclusionPatterns(ctx context.Context, src, dest string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, src, dest}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContextAndExclusionPatterns indicates an expected call of CopyWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) CopyWithContextAndExclusionPatterns(ctx, src, dest any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, src, dest}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).CopyWithContextAndExclusionPatterns), varargs...)
}

// CreateFile mocks base method.
func (m *MockICloseableFS) CreateFile(name string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateFile", name)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateFile indicates an expected call of CreateFile.
func (mr *MockICloseableFSMockRecorder) CreateFile(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateFile", reflect.TypeOf((*MockICloseableFS)(nil).CreateFile), name)
}

// CurrentDirectory mocks base method.
func (m *MockICloseableFS) CurrentDirectory() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentDirectory")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentDirectory indicates an expected call of CurrentDirectory.
func (mr *MockICloseableFSMockRecorder) CurrentDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentDirectory", reflect.TypeOf((*MockICloseableFS)(nil).CurrentDirectory))
}

// DiskUsage mocks base method.
func (m *MockICloseableFS) DiskUsage(name string) (filesystem.DiskUsage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiskUsage", name)
	ret0, _ := ret[0].(filesystem.DiskUsage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiskUsage indicates an expected call of DiskUsage.
func (mr *MockICloseableFSMockRecorder) DiskUsage(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskUsage", reflect.TypeOf((*MockICloseableFS)(nil).DiskUsage), name)
}

// ExcludeAll mocks base method.
func (m *MockICloseableFS) ExcludeAll(files []string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{files}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExcludeAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExcludeAll indicates an expected call of ExcludeAll.
func (mr *MockICloseableFSMockRecorder) ExcludeAll(files any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{files}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExcludeAll", reflect.TypeOf((*MockICloseableFS)(nil).ExcludeAll), varargs...)
}

// Exists mocks base method.
func (m *MockICloseableFS) Exists(path string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", path)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockICloseableFSMockRecorder) Exists(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockICloseableFS)(nil).Exists), path)
}

// FetchFileOwner mocks base method.
func (m *MockICloseableFS) FetchFileOwner(name string) (*user.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchFileOwner", name)
	ret0, _ := ret[0].(*user.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchFileOwner indicates an expected call of FetchFileOwner.
func (mr *MockICloseableFSMockRecorder) FetchFileOwner(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchFileOwner", reflect.TypeOf((*MockICloseableFS)(nil).FetchFileOwner), name)
}

// FetchOwners mocks base method.
func (m *MockICloseableFS) FetchOwners(name string) (int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOwners", name)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchOwners indicates an expected call of FetchOwners.
func (mr *MockICloseableFSMockRecorder) FetchOwners(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOwners", reflect.TypeOf((*MockICloseableFS)(nil).FetchOwners), name)
}

// FileHash mocks base method.
func (m *MockICloseableFS) FileHash(hashAlgo, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHash", hashAlgo, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHash indicates an expected call of FileHash.
func (mr *MockICloseableFSMockRecorder) FileHash(hashAlgo, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHash", reflect.TypeOf((*MockICloseableFS)(nil).FileHash), hashAlgo, path)
}

// FileHashWithContext mocks base method.
func (m *MockICloseableFS) FileHashWithContext(ctx context.Context, hashAlgo, path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHashWithContext", ctx, hashAlgo, path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHashWithContext indicates an expected call of FileHashWithContext.
func (mr *MockICloseableFSMockRecorder) FileHashWithContext(ctx, hashAlgo, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHashWithContext", reflect.TypeOf((*MockICloseableFS)(nil).FileHashWithContext), ctx, hashAlgo, path)
}

// FindAll mocks base method.
func (m *MockICloseableFS) FindAll(dir string, extensions ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{dir}
	for _, a := range extensions {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockICloseableFSMockRecorder) FindAll(dir any, extensions ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{dir}, extensions...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockICloseableFS)(nil).FindAll), varargs...)
}

// GarbageCollect mocks base method.
func (m *MockICloseableFS) GarbageCollect(root string, durationSinceLastAccess time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollect", root, durationSinceLastAccess)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollect indicates an expected call of GarbageCollect.
func (mr *MockICloseableFSMockRecorder) GarbageCollect(root, durationSinceLastAccess any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollect", reflect.TypeOf((*MockICloseableFS)(nil).GarbageCollect), root, durationSinceLastAccess)
}

// GarbageCollectWithContext mocks base method.
func (m *MockICloseableFS) GarbageCollectWithContext(ctx context.Context, root string, durationSinceLastAccess time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollectWithContext", ctx, root, durationSinceLastAccess)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollectWithContext indicates an expected call of GarbageCollectWithContext.
func (mr *MockICloseableFSMockRecorder) GarbageCollectWithContext(ctx, root, durationSinceLastAccess any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollectWithContext", reflect.TypeOf((*MockICloseableFS)(nil).GarbageCollectWithContext), ctx, root, durationSinceLastAccess)
}

// GenericOpen mocks base method.
func (m *MockICloseableFS) GenericOpen(name string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenericOpen", name)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenericOpen indicates an expected call of GenericOpen.
func (mr *MockICloseableFSMockRecorder) GenericOpen(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenericOpen", reflect.TypeOf((*MockICloseableFS)(nil).GenericOpen), name)
}

// GetFileSize mocks base method.
func (m *MockICloseableFS) GetFileSize(filename string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFileSize", filename)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFileSize indicates an expected call of GetFileSize.
func (mr *MockICloseableFSMockRecorder) GetFileSize(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileSize", reflect.TypeOf((*MockICloseableFS)(nil).GetFileSize), filename)
}

// GetType mocks base method.
func (m *MockICloseableFS) GetType() filesystem.FilesystemType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(filesystem.FilesystemType)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockICloseableFSMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockICloseableFS)(nil).GetType))
}

// Glob mocks base method.
func (m *MockICloseableFS) Glob(pattern string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Glob", pattern)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Glob indicates an expected call of Glob.
func (mr *MockICloseableFSMockRecorder) Glob(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Glob", reflect.TypeOf((*MockICloseableFS)(nil).Glob), pattern)
}

// IsDir mocks base method.
func (m *MockICloseableFS) IsDir(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDir indicates an expected call of IsDir.
func (mr *MockICloseableFSMockRecorder) IsDir(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockICloseableFS)(nil).IsDir), path)
}

// IsEmpty mocks base method.
func (m *MockICloseableFS) IsEmpty(name string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", name)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockICloseableFSMockRecorder) IsEmpty(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockICloseableFS)(nil).IsEmpty), name)
}

// IsFile mocks base method.
func (m *MockICloseableFS) IsFile(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFile", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsFile indicates an expected call of IsFile.
func (mr *MockICloseableFSMockRecorder) IsFile(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFile", reflect.TypeOf((*MockICloseableFS)(nil).IsFile), path)
}

// IsLink mocks base method.
func (m *MockICloseableFS) IsLink(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLink", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLink indicates an expected call of IsLink.
func (mr *MockICloseableFSMockRecorder) IsLink(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLink", reflect.TypeOf((*MockICloseableFS)(nil).IsLink), path)
}

// IsZip mocks base method.
func (m *MockICloseableFS) IsZip(filepath string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZip", filepath)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsZip indicates an expected call of IsZip.
func (mr *MockICloseableFSMockRecorder) IsZip(filepath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZip", reflect.TypeOf((*MockICloseableFS)(nil).IsZip), filepath)
}

// IsZipWithContext mocks base method.
func (m *MockICloseableFS) IsZipWithContext(ctx context.Context, filepath string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZipWithContext", ctx, filepath)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsZipWithContext indicates an expected call of IsZipWithContext.
func (mr *MockICloseableFSMockRecorder) IsZipWithContext(ctx, filepath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).IsZipWithContext), ctx, filepath)
}

// Link mocks base method.
func (m *MockICloseableFS) Link(oldname, newname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Link", oldname, newname)
	ret0, _ := ret[0].(error)
	return ret0
}

// Link indicates an expected call of Link.
func (mr *MockICloseableFSMockRecorder) Link(oldname, newname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Link", reflect.TypeOf((*MockICloseableFS)(nil).Link), oldname, newname)
}

// ListDirTree mocks base method.
func (m *MockICloseableFS) ListDirTree(dirPath string, list *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTree", dirPath, list)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTree indicates an expected call of ListDirTree.
func (mr *MockICloseableFSMockRecorder) ListDirTree(dirPath, list any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTree", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTree), dirPath, list)
}

// ListDirTreeWithContext mocks base method.
func (m *MockICloseableFS) ListDirTreeWithContext(ctx context.Context, dirPath string, list *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTreeWithContext", ctx, dirPath, list)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContext indicates an expected call of ListDirTreeWithContext.
func (mr *MockICloseableFSMockRecorder) ListDirTreeWithContext(ctx, dirPath, list any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTreeWithContext), ctx, dirPath, list)
}

// ListDirTreeWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) ListDirTreeWithContextAndExclusionPatterns(ctx context.Context, dirPath string, list *[]string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dirPath, list}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDirTreeWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContextAndExclusionPatterns indicates an expected call of ListDirTreeWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) ListDirTreeWithContextAndExclusionPatterns(ctx, dirPath, list any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dirPath, list}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTreeWithContextAndExclusionPatterns), varargs...)
}

// Lls mocks base method.
func (m *MockICloseableFS) Lls(dir string) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lls", dir)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lls indicates an expected call of Lls.
func (mr *MockICloseableFSMockRecorder) Lls(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lls", reflect.TypeOf((*MockICloseableFS)(nil).Lls), dir)
}

// LlsFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LlsFromOpenedDirectory(dir filesystem.File) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LlsFromOpenedDirectory", dir)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LlsFromOpenedDirectory indicates an expected call of LlsFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LlsFromOpenedDirectory(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LlsFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LlsFromOpenedDirectory), dir)
}

// Ls mocks base method.
func (m *MockICloseableFS) Ls(dir string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ls", dir)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ls indicates an expected call of Ls.
func (mr *MockICloseableFSMockRecorder) Ls(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ls", reflect.TypeOf((*MockICloseableFS)(nil).Ls), dir)
}

// LsFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LsFromOpenedDirectory(dir filesystem.File) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsFromOpenedDirectory", dir)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsFromOpenedDirectory indicates an expected call of LsFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LsFromOpenedDirectory(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LsFromOpenedDirectory), dir)
}

// LsRecursive mocks base method.
func (m *MockICloseableFS) LsRecursive(ctx context.Context, dir string, includeDirectories bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursive", ctx, dir, includeDirectories)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursive indicates an expected call of LsRecursive.
func (mr *MockICloseableFSMockRecorder) LsRecursive(ctx, dir, includeDirectories any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursive", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursive), ctx, dir, includeDirectories)
}

// LsRecursiveFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LsRecursiveFromOpenedDirectory(ctx context.Context, dir filesystem.File, includeDirectories bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursiveFromOpenedDirectory", ctx, dir, includeDirectories)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveFromOpenedDirectory indicates an expected call of LsRecursiveFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LsRecursiveFromOpenedDirectory(ctx, dir, includeDirectories any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveFromOpenedDirectory), ctx, dir, includeDirectories)
}

// LsRecursiveWithExclusionPatterns mocks base method.
func (m *MockICloseableFS) LsRecursiveWithExclusionPatterns(ctx context.Context, dir string, includeDirectories bool, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir, includeDirectories}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatterns indicates an expected call of LsRecursiveWithExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) LsRecursiveWithExclusionPatterns(ctx, dir, includeDirectories any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir, includeDirectories}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveWithExclusionPatterns), varargs...)
}

// LsRecursiveWithExclusionPatternsAndLimits mocks base method.
func (m *MockICloseableFS) LsRecursiveWithExclusionPatternsAndLimits(ctx context.Context, dir string, limit filesystem.ILimits, includeDirectories bool, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir, limit, includeDirectories}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatternsAndLimits", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatternsAndLimits indicates an expected call of LsRecursiveWithExclusionPatternsAndLimits.
func (mr *MockICloseableFSMockRecorder) LsRecursiveWithExclusionPatternsAndLimits(ctx, dir, limit, includeDirectories any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir, limit, includeDirectories}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatternsAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveWithExclusionPatternsAndLimits), varargs...)
}

// LsWithExclusionPatterns mocks base method.
func (m *MockICloseableFS) LsWithExclusionPatterns(dir string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsWithExclusionPatterns indicates an expected call of LsWithExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) LsWithExclusionPatterns(dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsWithExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).LsWithExclusionPatterns), varargs...)
}

// Lstat mocks base method.
func (m *MockICloseableFS) Lstat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockICloseableFSMockRecorder) Lstat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockICloseableFS)(nil).Lstat), name)
}

// MkDir mocks base method.
func (m *MockICloseableFS) MkDir(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDir", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDir indicates an expected call of MkDir.
func (mr *MockICloseableFSMockRecorder) MkDir(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDir", reflect.TypeOf((*MockICloseableFS)(nil).MkDir), dir)
}

// MkDirAll mocks base method.
func (m *MockICloseableFS) MkDirAll(dir string, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDirAll", dir, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDirAll indicates an expected call of MkDirAll.
func (mr *MockICloseableFSMockRecorder) MkDirAll(dir, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDirAll", reflect.TypeOf((*MockICloseableFS)(nil).MkDirAll), dir, perm)
}

// Move mocks base method.
func (m *MockICloseableFS) Move(src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Move", src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// Move indicates an expected call of Move.
func (mr *MockICloseableFSMockRecorder) Move(src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Move", reflect.TypeOf((*MockICloseableFS)(nil).Move), src, dest)
}

// MoveWithContext mocks base method.
func (m *MockICloseableFS) MoveWithContext(ctx context.Context, src, dest string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveWithContext", ctx, src, dest)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveWithContext indicates an expected call of MoveWithContext.
func (mr *MockICloseableFSMockRecorder) MoveWithContext(ctx, src, dest any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveWithContext", reflect.TypeOf((*MockICloseableFS)(nil).MoveWithContext), ctx, src, dest)
}

// NewRemoteLockFile mocks base method.
func (m *MockICloseableFS) NewRemoteLockFile(id, dirToLock string) filesystem.ILock {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewRemoteLockFile", id, dirToLock)
	ret0, _ := ret[0].(filesystem.ILock)
	return ret0
}

// NewRemoteLockFile indicates an expected call of NewRemoteLockFile.
func (mr *MockICloseableFSMockRecorder) NewRemoteLockFile(id, dirToLock any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewRemoteLockFile", reflect.TypeOf((*MockICloseableFS)(nil).NewRemoteLockFile), id, dirToLock)
}

// Open mocks base method.
func (m *MockICloseableFS) Open(name string) (v3.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", name)
	ret0, _ := ret[0].(v3.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockICloseableFSMockRecorder) Open(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockICloseableFS)(nil).Open), name)
}

// OpenFile mocks base method.
func (m *MockICloseableFS) OpenFile(name string, flag int, perm fs.FileMode) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", name, flag, perm)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockICloseableFSMockRecorder) OpenFile(name, flag, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockICloseableFS)(nil).OpenFile), name, flag, perm)
}

// PathSeparator mocks base method.
func (m *MockICloseableFS) PathSeparator() rune {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathSeparator")
	ret0, _ := ret[0].(rune)
	return ret0
}

// PathSeparator indicates an expected call of PathSeparator.
func (mr *MockICloseableFSMockRecorder) PathSeparator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathSeparator", reflect.TypeOf((*MockICloseableFS)(nil).PathSeparator))
}

// ReadFile mocks base method.
func (m *MockICloseableFS) ReadFile(filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockICloseableFSMockRecorder) ReadFile(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockICloseableFS)(nil).ReadFile), filename)
}

// ReadFileContent mocks base method.
func (m *MockICloseableFS) ReadFileContent(ctx context.Context, file filesystem.File, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileContent", ctx, file, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileContent indicates an expected call of ReadFileContent.
func (mr *MockICloseableFSMockRecorder) ReadFileContent(ctx, file, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileContent", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileContent), ctx, file, limits)
}

// ReadFileWithContext mocks base method.
func (m *MockICloseableFS) ReadFileWithContext(ctx context.Context, filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContext", ctx, filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContext indicates an expected call of ReadFileWithContext.
func (mr *MockICloseableFSMockRecorder) ReadFileWithContext(ctx, filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithContext), ctx, filename)
}

// ReadFileWithContextAndLimits mocks base method.
func (m *MockICloseableFS) ReadFileWithContextAndLimits(ctx context.Context, filename string, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContextAndLimits", ctx, filename, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContextAndLimits indicates an expected call of ReadFileWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) ReadFileWithContextAndLimits(ctx, filename, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithContextAndLimits), ctx, filename, limits)
}

// ReadFileWithLimits mocks base method.
func (m *MockICloseableFS) ReadFileWithLimits(filename string, limits filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithLimits", filename, limits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithLimits indicates an expected call of ReadFileWithLimits.
func (mr *MockICloseableFSMockRecorder) ReadFileWithLimits(filename, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithLimits", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithLimits), filename, limits)
}

// Readlink mocks base method.
func (m *MockICloseableFS) Readlink(name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockICloseableFSMockRecorder) Readlink(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockICloseableFS)(nil).Readlink), name)
}

// RemoveWithContext mocks base method.
func (m *MockICloseableFS) RemoveWithContext(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithContext", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContext indicates an expected call of RemoveWithContext.
func (mr *MockICloseableFSMockRecorder) RemoveWithContext(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContext", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithContext), ctx, dir)
}

// RemoveWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) RemoveWithContextAndExclusionPatterns(ctx context.Context, dir string, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dir}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContextAndExclusionPatterns indicates an expected call of RemoveWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) RemoveWithContextAndExclusionPatterns(ctx, dir any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dir}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithContextAndExclusionPatterns), varargs...)
}

// RemoveWithPrivileges mocks base method.
func (m *MockICloseableFS) RemoveWithPrivileges(ctx context.Context, dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithPrivileges", ctx, dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithPrivileges indicates an expected call of RemoveWithPrivileges.
func (mr *MockICloseableFSMockRecorder) RemoveWithPrivileges(ctx, dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithPrivileges", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithPrivileges), ctx, dir)
}

// Rm mocks base method.
func (m *MockICloseableFS) Rm(dir string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rm", dir)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rm indicates an expected call of Rm.
func (mr *MockICloseableFSMockRecorder) Rm(dir any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rm", reflect.TypeOf((*MockICloseableFS)(nil).Rm), dir)
}

// Stat mocks base method.
func (m *MockICloseableFS) Stat(name string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", name)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockICloseableFSMockRecorder) Stat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockICloseableFS)(nil).Stat), name)
}

// StatTimes mocks base method.
func (m *MockICloseableFS) StatTimes(name string) (filesystem.FileTimeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatTimes", name)
	ret0, _ := ret[0].(filesystem.FileTimeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatTimes indicates an expected call of StatTimes.
func (mr *MockICloseableFSMockRecorder) StatTimes(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatTimes", reflect.TypeOf((*MockICloseableFS)(nil).StatTimes), name)
}

// SubDirectories mocks base method.
func (m *MockICloseableFS) SubDirectories(directory string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectories", directory)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectories indicates an expected call of SubDirectories.
func (mr *MockICloseableFSMockRecorder) SubDirectories(directory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectories", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectories), directory)
}

// SubDirectoriesWithContext mocks base method.
func (m *MockICloseableFS) SubDirectoriesWithContext(ctx context.Context, directory string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectoriesWithContext", ctx, directory)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContext indicates an expected call of SubDirectoriesWithContext.
func (mr *MockICloseableFSMockRecorder) SubDirectoriesWithContext(ctx, directory any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContext", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectoriesWithContext), ctx, directory)
}

// SubDirectoriesWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) SubDirectoriesWithContextAndExclusionPatterns(ctx context.Context, directory string, exclusionPatterns ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, directory}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubDirectoriesWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContextAndExclusionPatterns indicates an expected call of SubDirectoriesWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) SubDirectoriesWithContextAndExclusionPatterns(ctx, directory any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, directory}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectoriesWithContextAndExclusionPatterns), varargs...)
}

// Symlink mocks base method.
func (m *MockICloseableFS) Symlink(oldname, newname string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Symlink", oldname, newname)
	ret0, _ := ret[0].(error)
	return ret0
}

// Symlink indicates an expected call of Symlink.
func (mr *MockICloseableFSMockRecorder) Symlink(oldname, newname any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Symlink", reflect.TypeOf((*MockICloseableFS)(nil).Symlink), oldname, newname)
}

// TempDir mocks base method.
func (m *MockICloseableFS) TempDir(dir, prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDir", dir, prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDir indicates an expected call of TempDir.
func (mr *MockICloseableFSMockRecorder) TempDir(dir, prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempDir), dir, prefix)
}

// TempDirInTempDir mocks base method.
func (m *MockICloseableFS) TempDirInTempDir(prefix string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirInTempDir", prefix)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDirInTempDir indicates an expected call of TempDirInTempDir.
func (mr *MockICloseableFSMockRecorder) TempDirInTempDir(prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempDirInTempDir), prefix)
}

// TempDirectory mocks base method.
func (m *MockICloseableFS) TempDirectory() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirectory")
	ret0, _ := ret[0].(string)
	return ret0
}

// TempDirectory indicates an expected call of TempDirectory.
func (mr *MockICloseableFSMockRecorder) TempDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirectory", reflect.TypeOf((*MockICloseableFS)(nil).TempDirectory))
}

// TempFile mocks base method.
func (m *MockICloseableFS) TempFile(dir, pattern string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFile", dir, pattern)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFile indicates an expected call of TempFile.
func (mr *MockICloseableFSMockRecorder) TempFile(dir, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFile", reflect.TypeOf((*MockICloseableFS)(nil).TempFile), dir, pattern)
}

// TempFileInTempDir mocks base method.
func (m *MockICloseableFS) TempFileInTempDir(pattern string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFileInTempDir", pattern)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFileInTempDir indicates an expected call of TempFileInTempDir.
func (mr *MockICloseableFSMockRecorder) TempFileInTempDir(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFileInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempFileInTempDir), pattern)
}

// Touch mocks base method.
func (m *MockICloseableFS) Touch(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Touch", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// Touch indicates an expected call of Touch.
func (mr *MockICloseableFSMockRecorder) Touch(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockICloseableFS)(nil).Touch), path)
}

// TouchTempFile mocks base method.
func (m *MockICloseableFS) TouchTempFile(dir, pattern string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFile", dir, pattern)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFile indicates an expected call of TouchTempFile.
func (mr *MockICloseableFSMockRecorder) TouchTempFile(dir, pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFile", reflect.TypeOf((*MockICloseableFS)(nil).TouchTempFile), dir, pattern)
}

// TouchTempFileInTempDir mocks base method.
func (m *MockICloseableFS) TouchTempFileInTempDir(pattern string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFileInTempDir", pattern)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFileInTempDir indicates an expected call of TouchTempFileInTempDir.
func (mr *MockICloseableFSMockRecorder) TouchTempFileInTempDir(pattern any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFileInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TouchTempFileInTempDir), pattern)
}

// Unzip mocks base method.
func (m *MockICloseableFS) Unzip(source, destination string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unzip", source, destination)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unzip indicates an expected call of Unzip.
func (mr *MockICloseableFSMockRecorder) Unzip(source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unzip", reflect.TypeOf((*MockICloseableFS)(nil).Unzip), source, destination)
}

// UnzipWithContext mocks base method.
func (m *MockICloseableFS) UnzipWithContext(ctx context.Context, source, destination string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContext", ctx, source, destination)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContext indicates an expected call of UnzipWithContext.
func (mr *MockICloseableFSMockRecorder) UnzipWithContext(ctx, source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).UnzipWithContext), ctx, source, destination)
}

// UnzipWithContextAndLimits mocks base method.
func (m *MockICloseableFS) UnzipWithContextAndLimits(ctx context.Context, source, destination string, limits filesystem.ILimits) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContextAndLimits", ctx, source, destination, limits)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContextAndLimits indicates an expected call of UnzipWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) UnzipWithContextAndLimits(ctx, source, destination, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).UnzipWithContextAndLimits), ctx, source, destination, limits)
}

// Walk mocks base method.
func (m *MockICloseableFS) Walk(root string, fn filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockICloseableFSMockRecorder) Walk(root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockICloseableFS)(nil).Walk), root, fn)
}

// WalkWithContext mocks base method.
func (m *MockICloseableFS) WalkWithContext(ctx context.Context, root string, fn filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkWithContext", ctx, root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContext indicates an expected call of WalkWithContext.
func (mr *MockICloseableFSMockRecorder) WalkWithContext(ctx, root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContext", reflect.TypeOf((*MockICloseableFS)(nil).WalkWithContext), ctx, root, fn)
}

// WalkWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) WalkWithContextAndExclusionPatterns(ctx context.Context, root string, fn filepath.WalkFunc, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, root, fn}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalkWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContextAndExclusionPatterns indicates an expected call of WalkWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) WalkWithContextAndExclusionPatterns(ctx, root, fn any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, root, fn}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).WalkWithContextAndExclusionPatterns), varargs...)
}

// WriteFile mocks base method.
func (m *MockICloseableFS) WriteFile(filename string, data []byte, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", filename, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockICloseableFSMockRecorder) WriteFile(filename, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockICloseableFS)(nil).WriteFile), filename, data, perm)
}

// WriteFileWithContext mocks base method.
func (m *MockICloseableFS) WriteFileWithContext(ctx context.Context, filename string, data []byte, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFileWithContext", ctx, filename, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFileWithContext indicates an expected call of WriteFileWithContext.
func (mr *MockICloseableFSMockRecorder) WriteFileWithContext(ctx, filename, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).WriteFileWithContext), ctx, filename, data, perm)
}

// WriteToFile mocks base method.
func (m *MockICloseableFS) WriteToFile(ctx context.Context, filename string, reader io.Reader, perm fs.FileMode) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteToFile", ctx, filename, reader, perm)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteToFile indicates an expected call of WriteToFile.
func (mr *MockICloseableFSMockRecorder) WriteToFile(ctx, filename, reader, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteToFile", reflect.TypeOf((*MockICloseableFS)(nil).WriteToFile), ctx, filename, reader, perm)
}

// Zip mocks base method.
func (m *MockICloseableFS) Zip(source, destination string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Zip", source, destination)
	ret0, _ := ret[0].(error)
	return ret0
}

// Zip indicates an expected call of Zip.
func (mr *MockICloseableFSMockRecorder) Zip(source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Zip", reflect.TypeOf((*MockICloseableFS)(nil).Zip), source, destination)
}

// ZipWithContext mocks base method.
func (m *MockICloseableFS) ZipWithContext(ctx context.Context, source, destination string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContext", ctx, source, destination)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContext indicates an expected call of ZipWithContext.
func (mr *MockICloseableFSMockRecorder) ZipWithContext(ctx, source, destination any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContext), ctx, source, destination)
}

// ZipWithContextAndLimits mocks base method.
func (m *MockICloseableFS) ZipWithContextAndLimits(ctx context.Context, source, destination string, limits filesystem.ILimits) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContextAndLimits", ctx, source, destination, limits)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimits indicates an expected call of ZipWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) ZipWithContextAndLimits(ctx, source, destination, limits any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContextAndLimits), ctx, source, destination, limits)
}

// ZipWithContextAndLimitsAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) ZipWithContextAndLimitsAndExclusionPatterns(ctx context.Context, source, destination string, limits filesystem.ILimits, exclusionPatterns ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, source, destination, limits}
	for _, a := range exclusionPatterns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZipWithContextAndLimitsAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimitsAndExclusionPatterns indicates an expected call of ZipWithContextAndLimitsAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) ZipWithContextAndLimitsAndExclusionPatterns(ctx, source, destination, limits any, exclusionPatterns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, source, destination, limits}, exclusionPatterns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimitsAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContextAndLimitsAndExclusionPatterns), varargs...)
}

// MockIForceRemover is a mock of IForceRemover interface.
type MockIForceRemover struct {
	ctrl     *gomock.Controller
	recorder *MockIForceRemoverMockRecorder
	isgomock struct{}
}

// MockIForceRemoverMockRecorder is the mock recorder for MockIForceRemover.
type MockIForceRemoverMockRecorder struct {
	mock *MockIForceRemover
}

// NewMockIForceRemover creates a new mock instance.
func NewMockIForceRemover(ctrl *gomock.Controller) *MockIForceRemover {
	mock := &MockIForceRemover{ctrl: ctrl}
	mock.recorder = &MockIForceRemoverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIForceRemover) EXPECT() *MockIForceRemoverMockRecorder {
	return m.recorder
}

// ForceRemoveIfPossible mocks base method.
func (m *MockIForceRemover) ForceRemoveIfPossible(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForceRemoveIfPossible", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// ForceRemoveIfPossible indicates an expected call of ForceRemoveIfPossible.
func (mr *MockIForceRemoverMockRecorder) ForceRemoveIfPossible(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForceRemoveIfPossible", reflect.TypeOf((*MockIForceRemover)(nil).ForceRemoveIfPossible), name)
}

// MockIStater is a mock of IStater interface.
type MockIStater struct {
	ctrl     *gomock.Controller
	recorder *MockIStaterMockRecorder
	isgomock struct{}
}

// MockIStaterMockRecorder is the mock recorder for MockIStater.
type MockIStaterMockRecorder struct {
	mock *MockIStater
}

// NewMockIStater creates a new mock instance.
func NewMockIStater(ctrl *gomock.Controller) *MockIStater {
	mock := &MockIStater{ctrl: ctrl}
	mock.recorder = &MockIStaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStater) EXPECT() *MockIStaterMockRecorder {
	return m.recorder
}

// LstatIfPossible mocks base method.
func (m *MockIStater) LstatIfPossible(arg0 string) (fs.FileInfo, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LstatIfPossible", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// LstatIfPossible indicates an expected call of LstatIfPossible.
func (mr *MockIStaterMockRecorder) LstatIfPossible(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LstatIfPossible", reflect.TypeOf((*MockIStater)(nil).LstatIfPossible), arg0)
}

// MockILinkReader is a mock of ILinkReader interface.
type MockILinkReader struct {
	ctrl     *gomock.Controller
	recorder *MockILinkReaderMockRecorder
	isgomock struct{}
}

// MockILinkReaderMockRecorder is the mock recorder for MockILinkReader.
type MockILinkReaderMockRecorder struct {
	mock *MockILinkReader
}

// NewMockILinkReader creates a new mock instance.
func NewMockILinkReader(ctrl *gomock.Controller) *MockILinkReader {
	mock := &MockILinkReader{ctrl: ctrl}
	mock.recorder = &MockILinkReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILinkReader) EXPECT() *MockILinkReaderMockRecorder {
	return m.recorder
}

// ReadlinkIfPossible mocks base method.
func (m *MockILinkReader) ReadlinkIfPossible(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadlinkIfPossible", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadlinkIfPossible indicates an expected call of ReadlinkIfPossible.
func (mr *MockILinkReaderMockRecorder) ReadlinkIfPossible(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadlinkIfPossible", reflect.TypeOf((*MockILinkReader)(nil).ReadlinkIfPossible), arg0)
}

// MockISymLinker is a mock of ISymLinker interface.
type MockISymLinker struct {
	ctrl     *gomock.Controller
	recorder *MockISymLinkerMockRecorder
	isgomock struct{}
}

// MockISymLinkerMockRecorder is the mock recorder for MockISymLinker.
type MockISymLinkerMockRecorder struct {
	mock *MockISymLinker
}

// NewMockISymLinker creates a new mock instance.
func NewMockISymLinker(ctrl *gomock.Controller) *MockISymLinker {
	mock := &MockISymLinker{ctrl: ctrl}
	mock.recorder = &MockISymLinkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISymLinker) EXPECT() *MockISymLinkerMockRecorder {
	return m.recorder
}

// SymlinkIfPossible mocks base method.
func (m *MockISymLinker) SymlinkIfPossible(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SymlinkIfPossible", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SymlinkIfPossible indicates an expected call of SymlinkIfPossible.
func (mr *MockISymLinkerMockRecorder) SymlinkIfPossible(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SymlinkIfPossible", reflect.TypeOf((*MockISymLinker)(nil).SymlinkIfPossible), arg0, arg1)
}
