// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ARM-software/golang-utils/utils/filesystem (interfaces: IFileHash,IChowner,ILinker,File,DiskUsage,FileTimeInfo,ILock,ILimits,FS,ICloseableFS,IForceRemover,IStater,ILinkReader,ISymLinker)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	fs "io/fs"
	user "os/user"
	filepath "path/filepath"
	reflect "reflect"
	time "time"

	filesystem "github.com/ARM-software/golang-utils/utils/filesystem"
	doublestar "github.com/bmatcuk/doublestar/v3"
	gomock "github.com/golang/mock/gomock"
)

// MockIFileHash is a mock of IFileHash interface.
type MockIFileHash struct {
	ctrl     *gomock.Controller
	recorder *MockIFileHashMockRecorder
}

// MockIFileHashMockRecorder is the mock recorder for MockIFileHash.
type MockIFileHashMockRecorder struct {
	mock *MockIFileHash
}

// NewMockIFileHash creates a new mock instance.
func NewMockIFileHash(ctrl *gomock.Controller) *MockIFileHash {
	mock := &MockIFileHash{ctrl: ctrl}
	mock.recorder = &MockIFileHashMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIFileHash) EXPECT() *MockIFileHashMockRecorder {
	return m.recorder
}

// Calculate mocks base method.
func (m *MockIFileHash) Calculate(arg0 filesystem.File) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Calculate", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Calculate indicates an expected call of Calculate.
func (mr *MockIFileHashMockRecorder) Calculate(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Calculate", reflect.TypeOf((*MockIFileHash)(nil).Calculate), arg0)
}

// CalculateFile mocks base method.
func (m *MockIFileHash) CalculateFile(arg0 filesystem.FS, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateFile", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateFile indicates an expected call of CalculateFile.
func (mr *MockIFileHashMockRecorder) CalculateFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateFile", reflect.TypeOf((*MockIFileHash)(nil).CalculateFile), arg0, arg1)
}

// CalculateFileWithContext mocks base method.
func (m *MockIFileHash) CalculateFileWithContext(arg0 context.Context, arg1 filesystem.FS, arg2 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateFileWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateFileWithContext indicates an expected call of CalculateFileWithContext.
func (mr *MockIFileHashMockRecorder) CalculateFileWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateFileWithContext", reflect.TypeOf((*MockIFileHash)(nil).CalculateFileWithContext), arg0, arg1, arg2)
}

// CalculateWithContext mocks base method.
func (m *MockIFileHash) CalculateWithContext(arg0 context.Context, arg1 filesystem.File) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CalculateWithContext", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CalculateWithContext indicates an expected call of CalculateWithContext.
func (mr *MockIFileHashMockRecorder) CalculateWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CalculateWithContext", reflect.TypeOf((*MockIFileHash)(nil).CalculateWithContext), arg0, arg1)
}

// GetType mocks base method.
func (m *MockIFileHash) GetType() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockIFileHashMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockIFileHash)(nil).GetType))
}

// MockIChowner is a mock of IChowner interface.
type MockIChowner struct {
	ctrl     *gomock.Controller
	recorder *MockIChownerMockRecorder
}

// MockIChownerMockRecorder is the mock recorder for MockIChowner.
type MockIChownerMockRecorder struct {
	mock *MockIChowner
}

// NewMockIChowner creates a new mock instance.
func NewMockIChowner(ctrl *gomock.Controller) *MockIChowner {
	mock := &MockIChowner{ctrl: ctrl}
	mock.recorder = &MockIChownerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIChowner) EXPECT() *MockIChownerMockRecorder {
	return m.recorder
}

// ChownIfPossible mocks base method.
func (m *MockIChowner) ChownIfPossible(arg0 string, arg1, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownIfPossible", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownIfPossible indicates an expected call of ChownIfPossible.
func (mr *MockIChownerMockRecorder) ChownIfPossible(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownIfPossible", reflect.TypeOf((*MockIChowner)(nil).ChownIfPossible), arg0, arg1, arg2)
}

// MockILinker is a mock of ILinker interface.
type MockILinker struct {
	ctrl     *gomock.Controller
	recorder *MockILinkerMockRecorder
}

// MockILinkerMockRecorder is the mock recorder for MockILinker.
type MockILinkerMockRecorder struct {
	mock *MockILinker
}

// NewMockILinker creates a new mock instance.
func NewMockILinker(ctrl *gomock.Controller) *MockILinker {
	mock := &MockILinker{ctrl: ctrl}
	mock.recorder = &MockILinkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILinker) EXPECT() *MockILinkerMockRecorder {
	return m.recorder
}

// LinkIfPossible mocks base method.
func (m *MockILinker) LinkIfPossible(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LinkIfPossible", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// LinkIfPossible indicates an expected call of LinkIfPossible.
func (mr *MockILinkerMockRecorder) LinkIfPossible(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LinkIfPossible", reflect.TypeOf((*MockILinker)(nil).LinkIfPossible), arg0, arg1)
}

// MockFile is a mock of File interface.
type MockFile struct {
	ctrl     *gomock.Controller
	recorder *MockFileMockRecorder
}

// MockFileMockRecorder is the mock recorder for MockFile.
type MockFileMockRecorder struct {
	mock *MockFile
}

// NewMockFile creates a new mock instance.
func NewMockFile(ctrl *gomock.Controller) *MockFile {
	mock := &MockFile{ctrl: ctrl}
	mock.recorder = &MockFileMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFile) EXPECT() *MockFileMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockFile) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockFileMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockFile)(nil).Close))
}

// Fd mocks base method.
func (m *MockFile) Fd() uintptr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fd")
	ret0, _ := ret[0].(uintptr)
	return ret0
}

// Fd indicates an expected call of Fd.
func (mr *MockFileMockRecorder) Fd() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fd", reflect.TypeOf((*MockFile)(nil).Fd))
}

// Name mocks base method.
func (m *MockFile) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockFileMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockFile)(nil).Name))
}

// Read mocks base method.
func (m *MockFile) Read(arg0 []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockFileMockRecorder) Read(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockFile)(nil).Read), arg0)
}

// ReadAt mocks base method.
func (m *MockFile) ReadAt(arg0 []byte, arg1 int64) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadAt", arg0, arg1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadAt indicates an expected call of ReadAt.
func (mr *MockFileMockRecorder) ReadAt(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadAt", reflect.TypeOf((*MockFile)(nil).ReadAt), arg0, arg1)
}

// Readdir mocks base method.
func (m *MockFile) Readdir(arg0 int) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readdir", arg0)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readdir indicates an expected call of Readdir.
func (mr *MockFileMockRecorder) Readdir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readdir", reflect.TypeOf((*MockFile)(nil).Readdir), arg0)
}

// Readdirnames mocks base method.
func (m *MockFile) Readdirnames(arg0 int) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readdirnames", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readdirnames indicates an expected call of Readdirnames.
func (mr *MockFileMockRecorder) Readdirnames(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readdirnames", reflect.TypeOf((*MockFile)(nil).Readdirnames), arg0)
}

// Seek mocks base method.
func (m *MockFile) Seek(arg0 int64, arg1 int) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Seek", arg0, arg1)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Seek indicates an expected call of Seek.
func (mr *MockFileMockRecorder) Seek(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seek", reflect.TypeOf((*MockFile)(nil).Seek), arg0, arg1)
}

// Stat mocks base method.
func (m *MockFile) Stat() (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat")
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFileMockRecorder) Stat() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFile)(nil).Stat))
}

// Sync mocks base method.
func (m *MockFile) Sync() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sync")
	ret0, _ := ret[0].(error)
	return ret0
}

// Sync indicates an expected call of Sync.
func (mr *MockFileMockRecorder) Sync() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockFile)(nil).Sync))
}

// Truncate mocks base method.
func (m *MockFile) Truncate(arg0 int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Truncate", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Truncate indicates an expected call of Truncate.
func (mr *MockFileMockRecorder) Truncate(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Truncate", reflect.TypeOf((*MockFile)(nil).Truncate), arg0)
}

// Write mocks base method.
func (m *MockFile) Write(arg0 []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockFileMockRecorder) Write(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockFile)(nil).Write), arg0)
}

// WriteAt mocks base method.
func (m *MockFile) WriteAt(arg0 []byte, arg1 int64) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteAt", arg0, arg1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteAt indicates an expected call of WriteAt.
func (mr *MockFileMockRecorder) WriteAt(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteAt", reflect.TypeOf((*MockFile)(nil).WriteAt), arg0, arg1)
}

// WriteString mocks base method.
func (m *MockFile) WriteString(arg0 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteString", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteString indicates an expected call of WriteString.
func (mr *MockFileMockRecorder) WriteString(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteString", reflect.TypeOf((*MockFile)(nil).WriteString), arg0)
}

// MockDiskUsage is a mock of DiskUsage interface.
type MockDiskUsage struct {
	ctrl     *gomock.Controller
	recorder *MockDiskUsageMockRecorder
}

// MockDiskUsageMockRecorder is the mock recorder for MockDiskUsage.
type MockDiskUsageMockRecorder struct {
	mock *MockDiskUsage
}

// NewMockDiskUsage creates a new mock instance.
func NewMockDiskUsage(ctrl *gomock.Controller) *MockDiskUsage {
	mock := &MockDiskUsage{ctrl: ctrl}
	mock.recorder = &MockDiskUsageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDiskUsage) EXPECT() *MockDiskUsageMockRecorder {
	return m.recorder
}

// GetFree mocks base method.
func (m *MockDiskUsage) GetFree() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFree")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetFree indicates an expected call of GetFree.
func (mr *MockDiskUsageMockRecorder) GetFree() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFree", reflect.TypeOf((*MockDiskUsage)(nil).GetFree))
}

// GetInodesFree mocks base method.
func (m *MockDiskUsage) GetInodesFree() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesFree")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesFree indicates an expected call of GetInodesFree.
func (mr *MockDiskUsageMockRecorder) GetInodesFree() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesFree", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesFree))
}

// GetInodesTotal mocks base method.
func (m *MockDiskUsage) GetInodesTotal() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesTotal")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesTotal indicates an expected call of GetInodesTotal.
func (mr *MockDiskUsageMockRecorder) GetInodesTotal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesTotal", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesTotal))
}

// GetInodesUsed mocks base method.
func (m *MockDiskUsage) GetInodesUsed() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesUsed")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetInodesUsed indicates an expected call of GetInodesUsed.
func (mr *MockDiskUsageMockRecorder) GetInodesUsed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesUsed", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesUsed))
}

// GetInodesUsedPercent mocks base method.
func (m *MockDiskUsage) GetInodesUsedPercent() float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInodesUsedPercent")
	ret0, _ := ret[0].(float64)
	return ret0
}

// GetInodesUsedPercent indicates an expected call of GetInodesUsedPercent.
func (mr *MockDiskUsageMockRecorder) GetInodesUsedPercent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInodesUsedPercent", reflect.TypeOf((*MockDiskUsage)(nil).GetInodesUsedPercent))
}

// GetTotal mocks base method.
func (m *MockDiskUsage) GetTotal() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotal")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotal indicates an expected call of GetTotal.
func (mr *MockDiskUsageMockRecorder) GetTotal() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotal", reflect.TypeOf((*MockDiskUsage)(nil).GetTotal))
}

// GetUsed mocks base method.
func (m *MockDiskUsage) GetUsed() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUsed")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetUsed indicates an expected call of GetUsed.
func (mr *MockDiskUsageMockRecorder) GetUsed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsed", reflect.TypeOf((*MockDiskUsage)(nil).GetUsed))
}

// GetUsedPercent mocks base method.
func (m *MockDiskUsage) GetUsedPercent() float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUsedPercent")
	ret0, _ := ret[0].(float64)
	return ret0
}

// GetUsedPercent indicates an expected call of GetUsedPercent.
func (mr *MockDiskUsageMockRecorder) GetUsedPercent() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUsedPercent", reflect.TypeOf((*MockDiskUsage)(nil).GetUsedPercent))
}

// MockFileTimeInfo is a mock of FileTimeInfo interface.
type MockFileTimeInfo struct {
	ctrl     *gomock.Controller
	recorder *MockFileTimeInfoMockRecorder
}

// MockFileTimeInfoMockRecorder is the mock recorder for MockFileTimeInfo.
type MockFileTimeInfoMockRecorder struct {
	mock *MockFileTimeInfo
}

// NewMockFileTimeInfo creates a new mock instance.
func NewMockFileTimeInfo(ctrl *gomock.Controller) *MockFileTimeInfo {
	mock := &MockFileTimeInfo{ctrl: ctrl}
	mock.recorder = &MockFileTimeInfoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileTimeInfo) EXPECT() *MockFileTimeInfoMockRecorder {
	return m.recorder
}

// AccessTime mocks base method.
func (m *MockFileTimeInfo) AccessTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AccessTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// AccessTime indicates an expected call of AccessTime.
func (mr *MockFileTimeInfoMockRecorder) AccessTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AccessTime", reflect.TypeOf((*MockFileTimeInfo)(nil).AccessTime))
}

// BirthTime mocks base method.
func (m *MockFileTimeInfo) BirthTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BirthTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// BirthTime indicates an expected call of BirthTime.
func (mr *MockFileTimeInfoMockRecorder) BirthTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BirthTime", reflect.TypeOf((*MockFileTimeInfo)(nil).BirthTime))
}

// ChangeTime mocks base method.
func (m *MockFileTimeInfo) ChangeTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// ChangeTime indicates an expected call of ChangeTime.
func (mr *MockFileTimeInfoMockRecorder) ChangeTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeTime", reflect.TypeOf((*MockFileTimeInfo)(nil).ChangeTime))
}

// HasAccessTime mocks base method.
func (m *MockFileTimeInfo) HasAccessTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasAccessTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasAccessTime indicates an expected call of HasAccessTime.
func (mr *MockFileTimeInfoMockRecorder) HasAccessTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasAccessTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasAccessTime))
}

// HasBirthTime mocks base method.
func (m *MockFileTimeInfo) HasBirthTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasBirthTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasBirthTime indicates an expected call of HasBirthTime.
func (mr *MockFileTimeInfoMockRecorder) HasBirthTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasBirthTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasBirthTime))
}

// HasChangeTime mocks base method.
func (m *MockFileTimeInfo) HasChangeTime() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasChangeTime")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasChangeTime indicates an expected call of HasChangeTime.
func (mr *MockFileTimeInfoMockRecorder) HasChangeTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasChangeTime", reflect.TypeOf((*MockFileTimeInfo)(nil).HasChangeTime))
}

// ModTime mocks base method.
func (m *MockFileTimeInfo) ModTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// ModTime indicates an expected call of ModTime.
func (mr *MockFileTimeInfoMockRecorder) ModTime() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModTime", reflect.TypeOf((*MockFileTimeInfo)(nil).ModTime))
}

// MockILock is a mock of ILock interface.
type MockILock struct {
	ctrl     *gomock.Controller
	recorder *MockILockMockRecorder
}

// MockILockMockRecorder is the mock recorder for MockILock.
type MockILockMockRecorder struct {
	mock *MockILock
}

// NewMockILock creates a new mock instance.
func NewMockILock(ctrl *gomock.Controller) *MockILock {
	mock := &MockILock{ctrl: ctrl}
	mock.recorder = &MockILockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILock) EXPECT() *MockILockMockRecorder {
	return m.recorder
}

// IsStale mocks base method.
func (m *MockILock) IsStale() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStale")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStale indicates an expected call of IsStale.
func (mr *MockILockMockRecorder) IsStale() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStale", reflect.TypeOf((*MockILock)(nil).IsStale))
}

// Lock mocks base method.
func (m *MockILock) Lock(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Lock indicates an expected call of Lock.
func (mr *MockILockMockRecorder) Lock(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockILock)(nil).Lock), arg0)
}

// LockWithTimeout mocks base method.
func (m *MockILock) LockWithTimeout(arg0 context.Context, arg1 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockWithTimeout", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// LockWithTimeout indicates an expected call of LockWithTimeout.
func (mr *MockILockMockRecorder) LockWithTimeout(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockWithTimeout", reflect.TypeOf((*MockILock)(nil).LockWithTimeout), arg0, arg1)
}

// MakeStale mocks base method.
func (m *MockILock) MakeStale(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MakeStale", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MakeStale indicates an expected call of MakeStale.
func (mr *MockILockMockRecorder) MakeStale(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeStale", reflect.TypeOf((*MockILock)(nil).MakeStale), arg0)
}

// ReleaseIfStale mocks base method.
func (m *MockILock) ReleaseIfStale(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReleaseIfStale", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReleaseIfStale indicates an expected call of ReleaseIfStale.
func (mr *MockILockMockRecorder) ReleaseIfStale(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseIfStale", reflect.TypeOf((*MockILock)(nil).ReleaseIfStale), arg0)
}

// TryLock mocks base method.
func (m *MockILock) TryLock(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryLock", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// TryLock indicates an expected call of TryLock.
func (mr *MockILockMockRecorder) TryLock(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryLock", reflect.TypeOf((*MockILock)(nil).TryLock), arg0)
}

// Unlock mocks base method.
func (m *MockILock) Unlock(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlock", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlock indicates an expected call of Unlock.
func (mr *MockILockMockRecorder) Unlock(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*MockILock)(nil).Unlock), arg0)
}

// MockILimits is a mock of ILimits interface.
type MockILimits struct {
	ctrl     *gomock.Controller
	recorder *MockILimitsMockRecorder
}

// MockILimitsMockRecorder is the mock recorder for MockILimits.
type MockILimitsMockRecorder struct {
	mock *MockILimits
}

// NewMockILimits creates a new mock instance.
func NewMockILimits(ctrl *gomock.Controller) *MockILimits {
	mock := &MockILimits{ctrl: ctrl}
	mock.recorder = &MockILimitsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILimits) EXPECT() *MockILimitsMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockILimits) Apply() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockILimitsMockRecorder) Apply() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockILimits)(nil).Apply))
}

// ApplyRecursively mocks base method.
func (m *MockILimits) ApplyRecursively() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ApplyRecursively")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ApplyRecursively indicates an expected call of ApplyRecursively.
func (mr *MockILimitsMockRecorder) ApplyRecursively() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyRecursively", reflect.TypeOf((*MockILimits)(nil).ApplyRecursively))
}

// GetMaxDepth mocks base method.
func (m *MockILimits) GetMaxDepth() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxDepth")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxDepth indicates an expected call of GetMaxDepth.
func (mr *MockILimitsMockRecorder) GetMaxDepth() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxDepth", reflect.TypeOf((*MockILimits)(nil).GetMaxDepth))
}

// GetMaxFileCount mocks base method.
func (m *MockILimits) GetMaxFileCount() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxFileCount")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxFileCount indicates an expected call of GetMaxFileCount.
func (mr *MockILimitsMockRecorder) GetMaxFileCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxFileCount", reflect.TypeOf((*MockILimits)(nil).GetMaxFileCount))
}

// GetMaxFileSize mocks base method.
func (m *MockILimits) GetMaxFileSize() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxFileSize")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetMaxFileSize indicates an expected call of GetMaxFileSize.
func (mr *MockILimitsMockRecorder) GetMaxFileSize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxFileSize", reflect.TypeOf((*MockILimits)(nil).GetMaxFileSize))
}

// GetMaxTotalSize mocks base method.
func (m *MockILimits) GetMaxTotalSize() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMaxTotalSize")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetMaxTotalSize indicates an expected call of GetMaxTotalSize.
func (mr *MockILimitsMockRecorder) GetMaxTotalSize() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxTotalSize", reflect.TypeOf((*MockILimits)(nil).GetMaxTotalSize))
}

// Validate mocks base method.
func (m *MockILimits) Validate() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate")
	ret0, _ := ret[0].(error)
	return ret0
}

// Validate indicates an expected call of Validate.
func (mr *MockILimitsMockRecorder) Validate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockILimits)(nil).Validate))
}

// MockFS is a mock of FS interface.
type MockFS struct {
	ctrl     *gomock.Controller
	recorder *MockFSMockRecorder
}

// MockFSMockRecorder is the mock recorder for MockFS.
type MockFSMockRecorder struct {
	mock *MockFS
}

// NewMockFS creates a new mock instance.
func NewMockFS(ctrl *gomock.Controller) *MockFS {
	mock := &MockFS{ctrl: ctrl}
	mock.recorder = &MockFSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFS) EXPECT() *MockFSMockRecorder {
	return m.recorder
}

// ChangeOwnership mocks base method.
func (m *MockFS) ChangeOwnership(arg0 string, arg1 *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnership", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnership indicates an expected call of ChangeOwnership.
func (mr *MockFSMockRecorder) ChangeOwnership(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnership", reflect.TypeOf((*MockFS)(nil).ChangeOwnership), arg0, arg1)
}

// ChangeOwnershipRecursively mocks base method.
func (m *MockFS) ChangeOwnershipRecursively(arg0 context.Context, arg1 string, arg2 *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnershipRecursively", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnershipRecursively indicates an expected call of ChangeOwnershipRecursively.
func (mr *MockFSMockRecorder) ChangeOwnershipRecursively(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnershipRecursively", reflect.TypeOf((*MockFS)(nil).ChangeOwnershipRecursively), arg0, arg1, arg2)
}

// Chmod mocks base method.
func (m *MockFS) Chmod(arg0 string, arg1 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockFSMockRecorder) Chmod(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockFS)(nil).Chmod), arg0, arg1)
}

// ChmodRecursively mocks base method.
func (m *MockFS) ChmodRecursively(arg0 context.Context, arg1 string, arg2 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChmodRecursively", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChmodRecursively indicates an expected call of ChmodRecursively.
func (mr *MockFSMockRecorder) ChmodRecursively(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChmodRecursively", reflect.TypeOf((*MockFS)(nil).ChmodRecursively), arg0, arg1, arg2)
}

// Chown mocks base method.
func (m *MockFS) Chown(arg0 string, arg1, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockFSMockRecorder) Chown(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockFS)(nil).Chown), arg0, arg1, arg2)
}

// ChownRecursively mocks base method.
func (m *MockFS) ChownRecursively(arg0 context.Context, arg1 string, arg2, arg3 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownRecursively", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownRecursively indicates an expected call of ChownRecursively.
func (mr *MockFSMockRecorder) ChownRecursively(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownRecursively", reflect.TypeOf((*MockFS)(nil).ChownRecursively), arg0, arg1, arg2, arg3)
}

// Chtimes mocks base method.
func (m *MockFS) Chtimes(arg0 string, arg1, arg2 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chtimes", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chtimes indicates an expected call of Chtimes.
func (mr *MockFSMockRecorder) Chtimes(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chtimes", reflect.TypeOf((*MockFS)(nil).Chtimes), arg0, arg1, arg2)
}

// CleanDir mocks base method.
func (m *MockFS) CleanDir(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDir", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDir indicates an expected call of CleanDir.
func (mr *MockFSMockRecorder) CleanDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDir", reflect.TypeOf((*MockFS)(nil).CleanDir), arg0)
}

// CleanDirWithContext mocks base method.
func (m *MockFS) CleanDirWithContext(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDirWithContext", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContext indicates an expected call of CleanDirWithContext.
func (mr *MockFSMockRecorder) CleanDirWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContext", reflect.TypeOf((*MockFS)(nil).CleanDirWithContext), arg0, arg1)
}

// CleanDirWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) CleanDirWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CleanDirWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContextAndExclusionPatterns indicates an expected call of CleanDirWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) CleanDirWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).CleanDirWithContextAndExclusionPatterns), varargs...)
}

// ConvertFilePath mocks base method.
func (m *MockFS) ConvertFilePath(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConvertFilePath", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// ConvertFilePath indicates an expected call of ConvertFilePath.
func (mr *MockFSMockRecorder) ConvertFilePath(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFilePath", reflect.TypeOf((*MockFS)(nil).ConvertFilePath), arg0)
}

// ConvertToAbsolutePath mocks base method.
func (m *MockFS) ConvertToAbsolutePath(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToAbsolutePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToAbsolutePath indicates an expected call of ConvertToAbsolutePath.
func (mr *MockFSMockRecorder) ConvertToAbsolutePath(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToAbsolutePath", reflect.TypeOf((*MockFS)(nil).ConvertToAbsolutePath), varargs...)
}

// ConvertToRelativePath mocks base method.
func (m *MockFS) ConvertToRelativePath(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToRelativePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToRelativePath indicates an expected call of ConvertToRelativePath.
func (mr *MockFSMockRecorder) ConvertToRelativePath(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToRelativePath", reflect.TypeOf((*MockFS)(nil).ConvertToRelativePath), varargs...)
}

// Copy mocks base method.
func (m *MockFS) Copy(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockFSMockRecorder) Copy(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockFS)(nil).Copy), arg0, arg1)
}

// CopyToDirectory mocks base method.
func (m *MockFS) CopyToDirectory(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectory", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectory indicates an expected call of CopyToDirectory.
func (mr *MockFSMockRecorder) CopyToDirectory(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectory", reflect.TypeOf((*MockFS)(nil).CopyToDirectory), arg0, arg1)
}

// CopyToDirectoryWithContext mocks base method.
func (m *MockFS) CopyToDirectoryWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectoryWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectoryWithContext indicates an expected call of CopyToDirectoryWithContext.
func (mr *MockFSMockRecorder) CopyToDirectoryWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectoryWithContext", reflect.TypeOf((*MockFS)(nil).CopyToDirectoryWithContext), arg0, arg1, arg2)
}

// CopyToFile mocks base method.
func (m *MockFS) CopyToFile(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFile", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFile indicates an expected call of CopyToFile.
func (mr *MockFSMockRecorder) CopyToFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFile", reflect.TypeOf((*MockFS)(nil).CopyToFile), arg0, arg1)
}

// CopyToFileWithContext mocks base method.
func (m *MockFS) CopyToFileWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFileWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFileWithContext indicates an expected call of CopyToFileWithContext.
func (mr *MockFSMockRecorder) CopyToFileWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFileWithContext", reflect.TypeOf((*MockFS)(nil).CopyToFileWithContext), arg0, arg1, arg2)
}

// CopyWithContext mocks base method.
func (m *MockFS) CopyWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContext indicates an expected call of CopyWithContext.
func (mr *MockFSMockRecorder) CopyWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContext", reflect.TypeOf((*MockFS)(nil).CopyWithContext), arg0, arg1, arg2)
}

// CopyWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) CopyWithContextAndExclusionPatterns(arg0 context.Context, arg1, arg2 string, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContextAndExclusionPatterns indicates an expected call of CopyWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) CopyWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).CopyWithContextAndExclusionPatterns), varargs...)
}

// CreateFile mocks base method.
func (m *MockFS) CreateFile(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateFile", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateFile indicates an expected call of CreateFile.
func (mr *MockFSMockRecorder) CreateFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateFile", reflect.TypeOf((*MockFS)(nil).CreateFile), arg0)
}

// CurrentDirectory mocks base method.
func (m *MockFS) CurrentDirectory() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentDirectory")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentDirectory indicates an expected call of CurrentDirectory.
func (mr *MockFSMockRecorder) CurrentDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentDirectory", reflect.TypeOf((*MockFS)(nil).CurrentDirectory))
}

// DiskUsage mocks base method.
func (m *MockFS) DiskUsage(arg0 string) (filesystem.DiskUsage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiskUsage", arg0)
	ret0, _ := ret[0].(filesystem.DiskUsage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiskUsage indicates an expected call of DiskUsage.
func (mr *MockFSMockRecorder) DiskUsage(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskUsage", reflect.TypeOf((*MockFS)(nil).DiskUsage), arg0)
}

// ExcludeAll mocks base method.
func (m *MockFS) ExcludeAll(arg0 []string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExcludeAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExcludeAll indicates an expected call of ExcludeAll.
func (mr *MockFSMockRecorder) ExcludeAll(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExcludeAll", reflect.TypeOf((*MockFS)(nil).ExcludeAll), varargs...)
}

// Exists mocks base method.
func (m *MockFS) Exists(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockFSMockRecorder) Exists(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockFS)(nil).Exists), arg0)
}

// FetchFileOwner mocks base method.
func (m *MockFS) FetchFileOwner(arg0 string) (*user.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchFileOwner", arg0)
	ret0, _ := ret[0].(*user.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchFileOwner indicates an expected call of FetchFileOwner.
func (mr *MockFSMockRecorder) FetchFileOwner(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchFileOwner", reflect.TypeOf((*MockFS)(nil).FetchFileOwner), arg0)
}

// FetchOwners mocks base method.
func (m *MockFS) FetchOwners(arg0 string) (int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOwners", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchOwners indicates an expected call of FetchOwners.
func (mr *MockFSMockRecorder) FetchOwners(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOwners", reflect.TypeOf((*MockFS)(nil).FetchOwners), arg0)
}

// FileHash mocks base method.
func (m *MockFS) FileHash(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHash", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHash indicates an expected call of FileHash.
func (mr *MockFSMockRecorder) FileHash(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHash", reflect.TypeOf((*MockFS)(nil).FileHash), arg0, arg1)
}

// FileHashWithContext mocks base method.
func (m *MockFS) FileHashWithContext(arg0 context.Context, arg1, arg2 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHashWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHashWithContext indicates an expected call of FileHashWithContext.
func (mr *MockFSMockRecorder) FileHashWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHashWithContext", reflect.TypeOf((*MockFS)(nil).FileHashWithContext), arg0, arg1, arg2)
}

// FindAll mocks base method.
func (m *MockFS) FindAll(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockFSMockRecorder) FindAll(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockFS)(nil).FindAll), varargs...)
}

// GarbageCollect mocks base method.
func (m *MockFS) GarbageCollect(arg0 string, arg1 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollect", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollect indicates an expected call of GarbageCollect.
func (mr *MockFSMockRecorder) GarbageCollect(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollect", reflect.TypeOf((*MockFS)(nil).GarbageCollect), arg0, arg1)
}

// GarbageCollectWithContext mocks base method.
func (m *MockFS) GarbageCollectWithContext(arg0 context.Context, arg1 string, arg2 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollectWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollectWithContext indicates an expected call of GarbageCollectWithContext.
func (mr *MockFSMockRecorder) GarbageCollectWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollectWithContext", reflect.TypeOf((*MockFS)(nil).GarbageCollectWithContext), arg0, arg1, arg2)
}

// GenericOpen mocks base method.
func (m *MockFS) GenericOpen(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenericOpen", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenericOpen indicates an expected call of GenericOpen.
func (mr *MockFSMockRecorder) GenericOpen(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenericOpen", reflect.TypeOf((*MockFS)(nil).GenericOpen), arg0)
}

// GetFileSize mocks base method.
func (m *MockFS) GetFileSize(arg0 string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFileSize", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFileSize indicates an expected call of GetFileSize.
func (mr *MockFSMockRecorder) GetFileSize(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileSize", reflect.TypeOf((*MockFS)(nil).GetFileSize), arg0)
}

// GetType mocks base method.
func (m *MockFS) GetType() filesystem.FilesystemType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(filesystem.FilesystemType)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockFSMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockFS)(nil).GetType))
}

// Glob mocks base method.
func (m *MockFS) Glob(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Glob", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Glob indicates an expected call of Glob.
func (mr *MockFSMockRecorder) Glob(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Glob", reflect.TypeOf((*MockFS)(nil).Glob), arg0)
}

// IsDir mocks base method.
func (m *MockFS) IsDir(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDir indicates an expected call of IsDir.
func (mr *MockFSMockRecorder) IsDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockFS)(nil).IsDir), arg0)
}

// IsEmpty mocks base method.
func (m *MockFS) IsEmpty(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockFSMockRecorder) IsEmpty(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockFS)(nil).IsEmpty), arg0)
}

// IsFile mocks base method.
func (m *MockFS) IsFile(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFile", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsFile indicates an expected call of IsFile.
func (mr *MockFSMockRecorder) IsFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFile", reflect.TypeOf((*MockFS)(nil).IsFile), arg0)
}

// IsLink mocks base method.
func (m *MockFS) IsLink(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLink", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLink indicates an expected call of IsLink.
func (mr *MockFSMockRecorder) IsLink(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLink", reflect.TypeOf((*MockFS)(nil).IsLink), arg0)
}

// IsZip mocks base method.
func (m *MockFS) IsZip(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZip", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsZip indicates an expected call of IsZip.
func (mr *MockFSMockRecorder) IsZip(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZip", reflect.TypeOf((*MockFS)(nil).IsZip), arg0)
}

// IsZipWithContext mocks base method.
func (m *MockFS) IsZipWithContext(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZipWithContext", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsZipWithContext indicates an expected call of IsZipWithContext.
func (mr *MockFSMockRecorder) IsZipWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZipWithContext", reflect.TypeOf((*MockFS)(nil).IsZipWithContext), arg0, arg1)
}

// Link mocks base method.
func (m *MockFS) Link(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Link", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Link indicates an expected call of Link.
func (mr *MockFSMockRecorder) Link(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Link", reflect.TypeOf((*MockFS)(nil).Link), arg0, arg1)
}

// ListDirTree mocks base method.
func (m *MockFS) ListDirTree(arg0 string, arg1 *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTree", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTree indicates an expected call of ListDirTree.
func (mr *MockFSMockRecorder) ListDirTree(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTree", reflect.TypeOf((*MockFS)(nil).ListDirTree), arg0, arg1)
}

// ListDirTreeWithContext mocks base method.
func (m *MockFS) ListDirTreeWithContext(arg0 context.Context, arg1 string, arg2 *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTreeWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContext indicates an expected call of ListDirTreeWithContext.
func (mr *MockFSMockRecorder) ListDirTreeWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContext", reflect.TypeOf((*MockFS)(nil).ListDirTreeWithContext), arg0, arg1, arg2)
}

// ListDirTreeWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) ListDirTreeWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 *[]string, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDirTreeWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContextAndExclusionPatterns indicates an expected call of ListDirTreeWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) ListDirTreeWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).ListDirTreeWithContextAndExclusionPatterns), varargs...)
}

// Lls mocks base method.
func (m *MockFS) Lls(arg0 string) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lls", arg0)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lls indicates an expected call of Lls.
func (mr *MockFSMockRecorder) Lls(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lls", reflect.TypeOf((*MockFS)(nil).Lls), arg0)
}

// LlsFromOpenedDirectory mocks base method.
func (m *MockFS) LlsFromOpenedDirectory(arg0 filesystem.File) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LlsFromOpenedDirectory", arg0)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LlsFromOpenedDirectory indicates an expected call of LlsFromOpenedDirectory.
func (mr *MockFSMockRecorder) LlsFromOpenedDirectory(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LlsFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LlsFromOpenedDirectory), arg0)
}

// Ls mocks base method.
func (m *MockFS) Ls(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ls", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ls indicates an expected call of Ls.
func (mr *MockFSMockRecorder) Ls(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ls", reflect.TypeOf((*MockFS)(nil).Ls), arg0)
}

// LsFromOpenedDirectory mocks base method.
func (m *MockFS) LsFromOpenedDirectory(arg0 filesystem.File) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsFromOpenedDirectory", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsFromOpenedDirectory indicates an expected call of LsFromOpenedDirectory.
func (mr *MockFSMockRecorder) LsFromOpenedDirectory(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LsFromOpenedDirectory), arg0)
}

// LsRecursive mocks base method.
func (m *MockFS) LsRecursive(arg0 context.Context, arg1 string, arg2 bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursive", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursive indicates an expected call of LsRecursive.
func (mr *MockFSMockRecorder) LsRecursive(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursive", reflect.TypeOf((*MockFS)(nil).LsRecursive), arg0, arg1, arg2)
}

// LsRecursiveFromOpenedDirectory mocks base method.
func (m *MockFS) LsRecursiveFromOpenedDirectory(arg0 context.Context, arg1 filesystem.File, arg2 bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursiveFromOpenedDirectory", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveFromOpenedDirectory indicates an expected call of LsRecursiveFromOpenedDirectory.
func (mr *MockFSMockRecorder) LsRecursiveFromOpenedDirectory(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveFromOpenedDirectory", reflect.TypeOf((*MockFS)(nil).LsRecursiveFromOpenedDirectory), arg0, arg1, arg2)
}

// LsRecursiveWithExclusionPatterns mocks base method.
func (m *MockFS) LsRecursiveWithExclusionPatterns(arg0 context.Context, arg1 string, arg2 bool, arg3 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatterns indicates an expected call of LsRecursiveWithExclusionPatterns.
func (mr *MockFSMockRecorder) LsRecursiveWithExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatterns", reflect.TypeOf((*MockFS)(nil).LsRecursiveWithExclusionPatterns), varargs...)
}

// LsRecursiveWithExclusionPatternsAndLimits mocks base method.
func (m *MockFS) LsRecursiveWithExclusionPatternsAndLimits(arg0 context.Context, arg1 string, arg2 filesystem.ILimits, arg3 bool, arg4 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatternsAndLimits", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatternsAndLimits indicates an expected call of LsRecursiveWithExclusionPatternsAndLimits.
func (mr *MockFSMockRecorder) LsRecursiveWithExclusionPatternsAndLimits(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatternsAndLimits", reflect.TypeOf((*MockFS)(nil).LsRecursiveWithExclusionPatternsAndLimits), varargs...)
}

// LsWithExclusionPatterns mocks base method.
func (m *MockFS) LsWithExclusionPatterns(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsWithExclusionPatterns indicates an expected call of LsWithExclusionPatterns.
func (mr *MockFSMockRecorder) LsWithExclusionPatterns(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsWithExclusionPatterns", reflect.TypeOf((*MockFS)(nil).LsWithExclusionPatterns), varargs...)
}

// Lstat mocks base method.
func (m *MockFS) Lstat(arg0 string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockFSMockRecorder) Lstat(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockFS)(nil).Lstat), arg0)
}

// MkDir mocks base method.
func (m *MockFS) MkDir(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDir", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDir indicates an expected call of MkDir.
func (mr *MockFSMockRecorder) MkDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDir", reflect.TypeOf((*MockFS)(nil).MkDir), arg0)
}

// MkDirAll mocks base method.
func (m *MockFS) MkDirAll(arg0 string, arg1 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDirAll", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDirAll indicates an expected call of MkDirAll.
func (mr *MockFSMockRecorder) MkDirAll(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDirAll", reflect.TypeOf((*MockFS)(nil).MkDirAll), arg0, arg1)
}

// Move mocks base method.
func (m *MockFS) Move(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Move", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Move indicates an expected call of Move.
func (mr *MockFSMockRecorder) Move(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Move", reflect.TypeOf((*MockFS)(nil).Move), arg0, arg1)
}

// MoveWithContext mocks base method.
func (m *MockFS) MoveWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveWithContext indicates an expected call of MoveWithContext.
func (mr *MockFSMockRecorder) MoveWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveWithContext", reflect.TypeOf((*MockFS)(nil).MoveWithContext), arg0, arg1, arg2)
}

// NewRemoteLockFile mocks base method.
func (m *MockFS) NewRemoteLockFile(arg0, arg1 string) filesystem.ILock {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewRemoteLockFile", arg0, arg1)
	ret0, _ := ret[0].(filesystem.ILock)
	return ret0
}

// NewRemoteLockFile indicates an expected call of NewRemoteLockFile.
func (mr *MockFSMockRecorder) NewRemoteLockFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewRemoteLockFile", reflect.TypeOf((*MockFS)(nil).NewRemoteLockFile), arg0, arg1)
}

// Open mocks base method.
func (m *MockFS) Open(arg0 string) (doublestar.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", arg0)
	ret0, _ := ret[0].(doublestar.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockFSMockRecorder) Open(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockFS)(nil).Open), arg0)
}

// OpenFile mocks base method.
func (m *MockFS) OpenFile(arg0 string, arg1 int, arg2 fs.FileMode) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", arg0, arg1, arg2)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockFSMockRecorder) OpenFile(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockFS)(nil).OpenFile), arg0, arg1, arg2)
}

// PathSeparator mocks base method.
func (m *MockFS) PathSeparator() int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathSeparator")
	ret0, _ := ret[0].(int32)
	return ret0
}

// PathSeparator indicates an expected call of PathSeparator.
func (mr *MockFSMockRecorder) PathSeparator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathSeparator", reflect.TypeOf((*MockFS)(nil).PathSeparator))
}

// ReadFile mocks base method.
func (m *MockFS) ReadFile(arg0 string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockFSMockRecorder) ReadFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockFS)(nil).ReadFile), arg0)
}

// ReadFileContent mocks base method.
func (m *MockFS) ReadFileContent(arg0 context.Context, arg1 filesystem.File, arg2 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileContent", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileContent indicates an expected call of ReadFileContent.
func (mr *MockFSMockRecorder) ReadFileContent(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileContent", reflect.TypeOf((*MockFS)(nil).ReadFileContent), arg0, arg1, arg2)
}

// ReadFileWithContext mocks base method.
func (m *MockFS) ReadFileWithContext(arg0 context.Context, arg1 string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContext", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContext indicates an expected call of ReadFileWithContext.
func (mr *MockFSMockRecorder) ReadFileWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContext", reflect.TypeOf((*MockFS)(nil).ReadFileWithContext), arg0, arg1)
}

// ReadFileWithContextAndLimits mocks base method.
func (m *MockFS) ReadFileWithContextAndLimits(arg0 context.Context, arg1 string, arg2 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContextAndLimits", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContextAndLimits indicates an expected call of ReadFileWithContextAndLimits.
func (mr *MockFSMockRecorder) ReadFileWithContextAndLimits(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).ReadFileWithContextAndLimits), arg0, arg1, arg2)
}

// ReadFileWithLimits mocks base method.
func (m *MockFS) ReadFileWithLimits(arg0 string, arg1 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithLimits", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithLimits indicates an expected call of ReadFileWithLimits.
func (mr *MockFSMockRecorder) ReadFileWithLimits(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithLimits", reflect.TypeOf((*MockFS)(nil).ReadFileWithLimits), arg0, arg1)
}

// Readlink mocks base method.
func (m *MockFS) Readlink(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockFSMockRecorder) Readlink(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockFS)(nil).Readlink), arg0)
}

// RemoveWithContext mocks base method.
func (m *MockFS) RemoveWithContext(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithContext", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContext indicates an expected call of RemoveWithContext.
func (mr *MockFSMockRecorder) RemoveWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContext", reflect.TypeOf((*MockFS)(nil).RemoveWithContext), arg0, arg1)
}

// RemoveWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) RemoveWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContextAndExclusionPatterns indicates an expected call of RemoveWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) RemoveWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).RemoveWithContextAndExclusionPatterns), varargs...)
}

// RemoveWithPrivileges mocks base method.
func (m *MockFS) RemoveWithPrivileges(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithPrivileges", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithPrivileges indicates an expected call of RemoveWithPrivileges.
func (mr *MockFSMockRecorder) RemoveWithPrivileges(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithPrivileges", reflect.TypeOf((*MockFS)(nil).RemoveWithPrivileges), arg0, arg1)
}

// Rm mocks base method.
func (m *MockFS) Rm(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rm", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rm indicates an expected call of Rm.
func (mr *MockFSMockRecorder) Rm(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rm", reflect.TypeOf((*MockFS)(nil).Rm), arg0)
}

// Stat mocks base method.
func (m *MockFS) Stat(arg0 string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFSMockRecorder) Stat(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFS)(nil).Stat), arg0)
}

// StatTimes mocks base method.
func (m *MockFS) StatTimes(arg0 string) (filesystem.FileTimeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatTimes", arg0)
	ret0, _ := ret[0].(filesystem.FileTimeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatTimes indicates an expected call of StatTimes.
func (mr *MockFSMockRecorder) StatTimes(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatTimes", reflect.TypeOf((*MockFS)(nil).StatTimes), arg0)
}

// SubDirectories mocks base method.
func (m *MockFS) SubDirectories(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectories", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectories indicates an expected call of SubDirectories.
func (mr *MockFSMockRecorder) SubDirectories(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectories", reflect.TypeOf((*MockFS)(nil).SubDirectories), arg0)
}

// SubDirectoriesWithContext mocks base method.
func (m *MockFS) SubDirectoriesWithContext(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectoriesWithContext", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContext indicates an expected call of SubDirectoriesWithContext.
func (mr *MockFSMockRecorder) SubDirectoriesWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContext", reflect.TypeOf((*MockFS)(nil).SubDirectoriesWithContext), arg0, arg1)
}

// SubDirectoriesWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) SubDirectoriesWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubDirectoriesWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContextAndExclusionPatterns indicates an expected call of SubDirectoriesWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) SubDirectoriesWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).SubDirectoriesWithContextAndExclusionPatterns), varargs...)
}

// Symlink mocks base method.
func (m *MockFS) Symlink(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Symlink", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Symlink indicates an expected call of Symlink.
func (mr *MockFSMockRecorder) Symlink(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Symlink", reflect.TypeOf((*MockFS)(nil).Symlink), arg0, arg1)
}

// TempDir mocks base method.
func (m *MockFS) TempDir(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDir", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDir indicates an expected call of TempDir.
func (mr *MockFSMockRecorder) TempDir(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDir", reflect.TypeOf((*MockFS)(nil).TempDir), arg0, arg1)
}

// TempDirInTempDir mocks base method.
func (m *MockFS) TempDirInTempDir(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirInTempDir", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDirInTempDir indicates an expected call of TempDirInTempDir.
func (mr *MockFSMockRecorder) TempDirInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirInTempDir", reflect.TypeOf((*MockFS)(nil).TempDirInTempDir), arg0)
}

// TempDirectory mocks base method.
func (m *MockFS) TempDirectory() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirectory")
	ret0, _ := ret[0].(string)
	return ret0
}

// TempDirectory indicates an expected call of TempDirectory.
func (mr *MockFSMockRecorder) TempDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirectory", reflect.TypeOf((*MockFS)(nil).TempDirectory))
}

// TempFile mocks base method.
func (m *MockFS) TempFile(arg0, arg1 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFile", arg0, arg1)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFile indicates an expected call of TempFile.
func (mr *MockFSMockRecorder) TempFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFile", reflect.TypeOf((*MockFS)(nil).TempFile), arg0, arg1)
}

// TempFileInTempDir mocks base method.
func (m *MockFS) TempFileInTempDir(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFileInTempDir", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFileInTempDir indicates an expected call of TempFileInTempDir.
func (mr *MockFSMockRecorder) TempFileInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFileInTempDir", reflect.TypeOf((*MockFS)(nil).TempFileInTempDir), arg0)
}

// Touch mocks base method.
func (m *MockFS) Touch(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Touch", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Touch indicates an expected call of Touch.
func (mr *MockFSMockRecorder) Touch(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockFS)(nil).Touch), arg0)
}

// TouchTempFile mocks base method.
func (m *MockFS) TouchTempFile(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFile", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFile indicates an expected call of TouchTempFile.
func (mr *MockFSMockRecorder) TouchTempFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFile", reflect.TypeOf((*MockFS)(nil).TouchTempFile), arg0, arg1)
}

// TouchTempFileInTempDir mocks base method.
func (m *MockFS) TouchTempFileInTempDir(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFileInTempDir", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFileInTempDir indicates an expected call of TouchTempFileInTempDir.
func (mr *MockFSMockRecorder) TouchTempFileInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFileInTempDir", reflect.TypeOf((*MockFS)(nil).TouchTempFileInTempDir), arg0)
}

// Unzip mocks base method.
func (m *MockFS) Unzip(arg0, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unzip", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unzip indicates an expected call of Unzip.
func (mr *MockFSMockRecorder) Unzip(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unzip", reflect.TypeOf((*MockFS)(nil).Unzip), arg0, arg1)
}

// UnzipWithContext mocks base method.
func (m *MockFS) UnzipWithContext(arg0 context.Context, arg1, arg2 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContext indicates an expected call of UnzipWithContext.
func (mr *MockFSMockRecorder) UnzipWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContext", reflect.TypeOf((*MockFS)(nil).UnzipWithContext), arg0, arg1, arg2)
}

// UnzipWithContextAndLimits mocks base method.
func (m *MockFS) UnzipWithContextAndLimits(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContextAndLimits", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContextAndLimits indicates an expected call of UnzipWithContextAndLimits.
func (mr *MockFSMockRecorder) UnzipWithContextAndLimits(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).UnzipWithContextAndLimits), arg0, arg1, arg2, arg3)
}

// Walk mocks base method.
func (m *MockFS) Walk(arg0 string, arg1 filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockFSMockRecorder) Walk(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockFS)(nil).Walk), arg0, arg1)
}

// WalkWithContext mocks base method.
func (m *MockFS) WalkWithContext(arg0 context.Context, arg1 string, arg2 filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContext indicates an expected call of WalkWithContext.
func (mr *MockFSMockRecorder) WalkWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContext", reflect.TypeOf((*MockFS)(nil).WalkWithContext), arg0, arg1, arg2)
}

// WalkWithContextAndExclusionPatterns mocks base method.
func (m *MockFS) WalkWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 filepath.WalkFunc, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalkWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContextAndExclusionPatterns indicates an expected call of WalkWithContextAndExclusionPatterns.
func (mr *MockFSMockRecorder) WalkWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContextAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).WalkWithContextAndExclusionPatterns), varargs...)
}

// WriteFile mocks base method.
func (m *MockFS) WriteFile(arg0 string, arg1 []byte, arg2 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockFSMockRecorder) WriteFile(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockFS)(nil).WriteFile), arg0, arg1, arg2)
}

// WriteFileWithContext mocks base method.
func (m *MockFS) WriteFileWithContext(arg0 context.Context, arg1 string, arg2 []byte, arg3 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFileWithContext", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFileWithContext indicates an expected call of WriteFileWithContext.
func (mr *MockFSMockRecorder) WriteFileWithContext(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFileWithContext", reflect.TypeOf((*MockFS)(nil).WriteFileWithContext), arg0, arg1, arg2, arg3)
}

// WriteToFile mocks base method.
func (m *MockFS) WriteToFile(arg0 context.Context, arg1 string, arg2 io.Reader, arg3 fs.FileMode) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteToFile", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteToFile indicates an expected call of WriteToFile.
func (mr *MockFSMockRecorder) WriteToFile(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteToFile", reflect.TypeOf((*MockFS)(nil).WriteToFile), arg0, arg1, arg2, arg3)
}

// Zip mocks base method.
func (m *MockFS) Zip(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Zip", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Zip indicates an expected call of Zip.
func (mr *MockFSMockRecorder) Zip(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Zip", reflect.TypeOf((*MockFS)(nil).Zip), arg0, arg1)
}

// ZipWithContext mocks base method.
func (m *MockFS) ZipWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContext indicates an expected call of ZipWithContext.
func (mr *MockFSMockRecorder) ZipWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContext", reflect.TypeOf((*MockFS)(nil).ZipWithContext), arg0, arg1, arg2)
}

// ZipWithContextAndLimits mocks base method.
func (m *MockFS) ZipWithContextAndLimits(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContextAndLimits", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimits indicates an expected call of ZipWithContextAndLimits.
func (mr *MockFSMockRecorder) ZipWithContextAndLimits(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimits", reflect.TypeOf((*MockFS)(nil).ZipWithContextAndLimits), arg0, arg1, arg2, arg3)
}

// ZipWithContextAndLimitsAndExclusionPatterns mocks base method.
func (m *MockFS) ZipWithContextAndLimitsAndExclusionPatterns(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits, arg4 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZipWithContextAndLimitsAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimitsAndExclusionPatterns indicates an expected call of ZipWithContextAndLimitsAndExclusionPatterns.
func (mr *MockFSMockRecorder) ZipWithContextAndLimitsAndExclusionPatterns(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimitsAndExclusionPatterns", reflect.TypeOf((*MockFS)(nil).ZipWithContextAndLimitsAndExclusionPatterns), varargs...)
}

// MockICloseableFS is a mock of ICloseableFS interface.
type MockICloseableFS struct {
	ctrl     *gomock.Controller
	recorder *MockICloseableFSMockRecorder
}

// MockICloseableFSMockRecorder is the mock recorder for MockICloseableFS.
type MockICloseableFSMockRecorder struct {
	mock *MockICloseableFS
}

// NewMockICloseableFS creates a new mock instance.
func NewMockICloseableFS(ctrl *gomock.Controller) *MockICloseableFS {
	mock := &MockICloseableFS{ctrl: ctrl}
	mock.recorder = &MockICloseableFSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICloseableFS) EXPECT() *MockICloseableFSMockRecorder {
	return m.recorder
}

// ChangeOwnership mocks base method.
func (m *MockICloseableFS) ChangeOwnership(arg0 string, arg1 *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnership", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnership indicates an expected call of ChangeOwnership.
func (mr *MockICloseableFSMockRecorder) ChangeOwnership(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnership", reflect.TypeOf((*MockICloseableFS)(nil).ChangeOwnership), arg0, arg1)
}

// ChangeOwnershipRecursively mocks base method.
func (m *MockICloseableFS) ChangeOwnershipRecursively(arg0 context.Context, arg1 string, arg2 *user.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOwnershipRecursively", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOwnershipRecursively indicates an expected call of ChangeOwnershipRecursively.
func (mr *MockICloseableFSMockRecorder) ChangeOwnershipRecursively(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOwnershipRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChangeOwnershipRecursively), arg0, arg1, arg2)
}

// Chmod mocks base method.
func (m *MockICloseableFS) Chmod(arg0 string, arg1 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockICloseableFSMockRecorder) Chmod(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockICloseableFS)(nil).Chmod), arg0, arg1)
}

// ChmodRecursively mocks base method.
func (m *MockICloseableFS) ChmodRecursively(arg0 context.Context, arg1 string, arg2 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChmodRecursively", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChmodRecursively indicates an expected call of ChmodRecursively.
func (mr *MockICloseableFSMockRecorder) ChmodRecursively(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChmodRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChmodRecursively), arg0, arg1, arg2)
}

// Chown mocks base method.
func (m *MockICloseableFS) Chown(arg0 string, arg1, arg2 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chown", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chown indicates an expected call of Chown.
func (mr *MockICloseableFSMockRecorder) Chown(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chown", reflect.TypeOf((*MockICloseableFS)(nil).Chown), arg0, arg1, arg2)
}

// ChownRecursively mocks base method.
func (m *MockICloseableFS) ChownRecursively(arg0 context.Context, arg1 string, arg2, arg3 int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChownRecursively", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChownRecursively indicates an expected call of ChownRecursively.
func (mr *MockICloseableFSMockRecorder) ChownRecursively(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChownRecursively", reflect.TypeOf((*MockICloseableFS)(nil).ChownRecursively), arg0, arg1, arg2, arg3)
}

// Chtimes mocks base method.
func (m *MockICloseableFS) Chtimes(arg0 string, arg1, arg2 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chtimes", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chtimes indicates an expected call of Chtimes.
func (mr *MockICloseableFSMockRecorder) Chtimes(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chtimes", reflect.TypeOf((*MockICloseableFS)(nil).Chtimes), arg0, arg1, arg2)
}

// CleanDir mocks base method.
func (m *MockICloseableFS) CleanDir(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDir", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDir indicates an expected call of CleanDir.
func (mr *MockICloseableFSMockRecorder) CleanDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDir", reflect.TypeOf((*MockICloseableFS)(nil).CleanDir), arg0)
}

// CleanDirWithContext mocks base method.
func (m *MockICloseableFS) CleanDirWithContext(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanDirWithContext", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContext indicates an expected call of CleanDirWithContext.
func (mr *MockICloseableFSMockRecorder) CleanDirWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CleanDirWithContext), arg0, arg1)
}

// CleanDirWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) CleanDirWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CleanDirWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanDirWithContextAndExclusionPatterns indicates an expected call of CleanDirWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) CleanDirWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanDirWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).CleanDirWithContextAndExclusionPatterns), varargs...)
}

// Close mocks base method.
func (m *MockICloseableFS) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockICloseableFSMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockICloseableFS)(nil).Close))
}

// ConvertFilePath mocks base method.
func (m *MockICloseableFS) ConvertFilePath(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConvertFilePath", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// ConvertFilePath indicates an expected call of ConvertFilePath.
func (mr *MockICloseableFSMockRecorder) ConvertFilePath(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertFilePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertFilePath), arg0)
}

// ConvertToAbsolutePath mocks base method.
func (m *MockICloseableFS) ConvertToAbsolutePath(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToAbsolutePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToAbsolutePath indicates an expected call of ConvertToAbsolutePath.
func (mr *MockICloseableFSMockRecorder) ConvertToAbsolutePath(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToAbsolutePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertToAbsolutePath), varargs...)
}

// ConvertToRelativePath mocks base method.
func (m *MockICloseableFS) ConvertToRelativePath(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConvertToRelativePath", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConvertToRelativePath indicates an expected call of ConvertToRelativePath.
func (mr *MockICloseableFSMockRecorder) ConvertToRelativePath(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConvertToRelativePath", reflect.TypeOf((*MockICloseableFS)(nil).ConvertToRelativePath), varargs...)
}

// Copy mocks base method.
func (m *MockICloseableFS) Copy(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockICloseableFSMockRecorder) Copy(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockICloseableFS)(nil).Copy), arg0, arg1)
}

// CopyToDirectory mocks base method.
func (m *MockICloseableFS) CopyToDirectory(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectory", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectory indicates an expected call of CopyToDirectory.
func (mr *MockICloseableFSMockRecorder) CopyToDirectory(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectory", reflect.TypeOf((*MockICloseableFS)(nil).CopyToDirectory), arg0, arg1)
}

// CopyToDirectoryWithContext mocks base method.
func (m *MockICloseableFS) CopyToDirectoryWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToDirectoryWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToDirectoryWithContext indicates an expected call of CopyToDirectoryWithContext.
func (mr *MockICloseableFSMockRecorder) CopyToDirectoryWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToDirectoryWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyToDirectoryWithContext), arg0, arg1, arg2)
}

// CopyToFile mocks base method.
func (m *MockICloseableFS) CopyToFile(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFile", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFile indicates an expected call of CopyToFile.
func (mr *MockICloseableFSMockRecorder) CopyToFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFile", reflect.TypeOf((*MockICloseableFS)(nil).CopyToFile), arg0, arg1)
}

// CopyToFileWithContext mocks base method.
func (m *MockICloseableFS) CopyToFileWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyToFileWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyToFileWithContext indicates an expected call of CopyToFileWithContext.
func (mr *MockICloseableFSMockRecorder) CopyToFileWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyToFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyToFileWithContext), arg0, arg1, arg2)
}

// CopyWithContext mocks base method.
func (m *MockICloseableFS) CopyWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContext indicates an expected call of CopyWithContext.
func (mr *MockICloseableFSMockRecorder) CopyWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContext", reflect.TypeOf((*MockICloseableFS)(nil).CopyWithContext), arg0, arg1, arg2)
}

// CopyWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) CopyWithContextAndExclusionPatterns(arg0 context.Context, arg1, arg2 string, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CopyWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyWithContextAndExclusionPatterns indicates an expected call of CopyWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) CopyWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).CopyWithContextAndExclusionPatterns), varargs...)
}

// CreateFile mocks base method.
func (m *MockICloseableFS) CreateFile(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateFile", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateFile indicates an expected call of CreateFile.
func (mr *MockICloseableFSMockRecorder) CreateFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateFile", reflect.TypeOf((*MockICloseableFS)(nil).CreateFile), arg0)
}

// CurrentDirectory mocks base method.
func (m *MockICloseableFS) CurrentDirectory() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentDirectory")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentDirectory indicates an expected call of CurrentDirectory.
func (mr *MockICloseableFSMockRecorder) CurrentDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentDirectory", reflect.TypeOf((*MockICloseableFS)(nil).CurrentDirectory))
}

// DiskUsage mocks base method.
func (m *MockICloseableFS) DiskUsage(arg0 string) (filesystem.DiskUsage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiskUsage", arg0)
	ret0, _ := ret[0].(filesystem.DiskUsage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DiskUsage indicates an expected call of DiskUsage.
func (mr *MockICloseableFSMockRecorder) DiskUsage(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskUsage", reflect.TypeOf((*MockICloseableFS)(nil).DiskUsage), arg0)
}

// ExcludeAll mocks base method.
func (m *MockICloseableFS) ExcludeAll(arg0 []string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExcludeAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExcludeAll indicates an expected call of ExcludeAll.
func (mr *MockICloseableFSMockRecorder) ExcludeAll(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExcludeAll", reflect.TypeOf((*MockICloseableFS)(nil).ExcludeAll), varargs...)
}

// Exists mocks base method.
func (m *MockICloseableFS) Exists(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockICloseableFSMockRecorder) Exists(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockICloseableFS)(nil).Exists), arg0)
}

// FetchFileOwner mocks base method.
func (m *MockICloseableFS) FetchFileOwner(arg0 string) (*user.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchFileOwner", arg0)
	ret0, _ := ret[0].(*user.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchFileOwner indicates an expected call of FetchFileOwner.
func (mr *MockICloseableFSMockRecorder) FetchFileOwner(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchFileOwner", reflect.TypeOf((*MockICloseableFS)(nil).FetchFileOwner), arg0)
}

// FetchOwners mocks base method.
func (m *MockICloseableFS) FetchOwners(arg0 string) (int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOwners", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchOwners indicates an expected call of FetchOwners.
func (mr *MockICloseableFSMockRecorder) FetchOwners(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOwners", reflect.TypeOf((*MockICloseableFS)(nil).FetchOwners), arg0)
}

// FileHash mocks base method.
func (m *MockICloseableFS) FileHash(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHash", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHash indicates an expected call of FileHash.
func (mr *MockICloseableFSMockRecorder) FileHash(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHash", reflect.TypeOf((*MockICloseableFS)(nil).FileHash), arg0, arg1)
}

// FileHashWithContext mocks base method.
func (m *MockICloseableFS) FileHashWithContext(arg0 context.Context, arg1, arg2 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileHashWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileHashWithContext indicates an expected call of FileHashWithContext.
func (mr *MockICloseableFSMockRecorder) FileHashWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileHashWithContext", reflect.TypeOf((*MockICloseableFS)(nil).FileHashWithContext), arg0, arg1, arg2)
}

// FindAll mocks base method.
func (m *MockICloseableFS) FindAll(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindAll", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockICloseableFSMockRecorder) FindAll(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockICloseableFS)(nil).FindAll), varargs...)
}

// GarbageCollect mocks base method.
func (m *MockICloseableFS) GarbageCollect(arg0 string, arg1 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollect", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollect indicates an expected call of GarbageCollect.
func (mr *MockICloseableFSMockRecorder) GarbageCollect(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollect", reflect.TypeOf((*MockICloseableFS)(nil).GarbageCollect), arg0, arg1)
}

// GarbageCollectWithContext mocks base method.
func (m *MockICloseableFS) GarbageCollectWithContext(arg0 context.Context, arg1 string, arg2 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GarbageCollectWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// GarbageCollectWithContext indicates an expected call of GarbageCollectWithContext.
func (mr *MockICloseableFSMockRecorder) GarbageCollectWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GarbageCollectWithContext", reflect.TypeOf((*MockICloseableFS)(nil).GarbageCollectWithContext), arg0, arg1, arg2)
}

// GenericOpen mocks base method.
func (m *MockICloseableFS) GenericOpen(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenericOpen", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenericOpen indicates an expected call of GenericOpen.
func (mr *MockICloseableFSMockRecorder) GenericOpen(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenericOpen", reflect.TypeOf((*MockICloseableFS)(nil).GenericOpen), arg0)
}

// GetFileSize mocks base method.
func (m *MockICloseableFS) GetFileSize(arg0 string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFileSize", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFileSize indicates an expected call of GetFileSize.
func (mr *MockICloseableFSMockRecorder) GetFileSize(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileSize", reflect.TypeOf((*MockICloseableFS)(nil).GetFileSize), arg0)
}

// GetType mocks base method.
func (m *MockICloseableFS) GetType() filesystem.FilesystemType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetType")
	ret0, _ := ret[0].(filesystem.FilesystemType)
	return ret0
}

// GetType indicates an expected call of GetType.
func (mr *MockICloseableFSMockRecorder) GetType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetType", reflect.TypeOf((*MockICloseableFS)(nil).GetType))
}

// Glob mocks base method.
func (m *MockICloseableFS) Glob(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Glob", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Glob indicates an expected call of Glob.
func (mr *MockICloseableFSMockRecorder) Glob(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Glob", reflect.TypeOf((*MockICloseableFS)(nil).Glob), arg0)
}

// IsDir mocks base method.
func (m *MockICloseableFS) IsDir(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDir", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDir indicates an expected call of IsDir.
func (mr *MockICloseableFSMockRecorder) IsDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDir", reflect.TypeOf((*MockICloseableFS)(nil).IsDir), arg0)
}

// IsEmpty mocks base method.
func (m *MockICloseableFS) IsEmpty(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockICloseableFSMockRecorder) IsEmpty(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockICloseableFS)(nil).IsEmpty), arg0)
}

// IsFile mocks base method.
func (m *MockICloseableFS) IsFile(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsFile", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsFile indicates an expected call of IsFile.
func (mr *MockICloseableFSMockRecorder) IsFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsFile", reflect.TypeOf((*MockICloseableFS)(nil).IsFile), arg0)
}

// IsLink mocks base method.
func (m *MockICloseableFS) IsLink(arg0 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLink", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLink indicates an expected call of IsLink.
func (mr *MockICloseableFSMockRecorder) IsLink(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLink", reflect.TypeOf((*MockICloseableFS)(nil).IsLink), arg0)
}

// IsZip mocks base method.
func (m *MockICloseableFS) IsZip(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZip", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsZip indicates an expected call of IsZip.
func (mr *MockICloseableFSMockRecorder) IsZip(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZip", reflect.TypeOf((*MockICloseableFS)(nil).IsZip), arg0)
}

// IsZipWithContext mocks base method.
func (m *MockICloseableFS) IsZipWithContext(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsZipWithContext", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsZipWithContext indicates an expected call of IsZipWithContext.
func (mr *MockICloseableFSMockRecorder) IsZipWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsZipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).IsZipWithContext), arg0, arg1)
}

// Link mocks base method.
func (m *MockICloseableFS) Link(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Link", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Link indicates an expected call of Link.
func (mr *MockICloseableFSMockRecorder) Link(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Link", reflect.TypeOf((*MockICloseableFS)(nil).Link), arg0, arg1)
}

// ListDirTree mocks base method.
func (m *MockICloseableFS) ListDirTree(arg0 string, arg1 *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTree", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTree indicates an expected call of ListDirTree.
func (mr *MockICloseableFSMockRecorder) ListDirTree(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTree", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTree), arg0, arg1)
}

// ListDirTreeWithContext mocks base method.
func (m *MockICloseableFS) ListDirTreeWithContext(arg0 context.Context, arg1 string, arg2 *[]string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListDirTreeWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContext indicates an expected call of ListDirTreeWithContext.
func (mr *MockICloseableFSMockRecorder) ListDirTreeWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTreeWithContext), arg0, arg1, arg2)
}

// ListDirTreeWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) ListDirTreeWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 *[]string, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDirTreeWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListDirTreeWithContextAndExclusionPatterns indicates an expected call of ListDirTreeWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) ListDirTreeWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDirTreeWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).ListDirTreeWithContextAndExclusionPatterns), varargs...)
}

// Lls mocks base method.
func (m *MockICloseableFS) Lls(arg0 string) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lls", arg0)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lls indicates an expected call of Lls.
func (mr *MockICloseableFSMockRecorder) Lls(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lls", reflect.TypeOf((*MockICloseableFS)(nil).Lls), arg0)
}

// LlsFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LlsFromOpenedDirectory(arg0 filesystem.File) ([]fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LlsFromOpenedDirectory", arg0)
	ret0, _ := ret[0].([]fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LlsFromOpenedDirectory indicates an expected call of LlsFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LlsFromOpenedDirectory(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LlsFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LlsFromOpenedDirectory), arg0)
}

// Ls mocks base method.
func (m *MockICloseableFS) Ls(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ls", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ls indicates an expected call of Ls.
func (mr *MockICloseableFSMockRecorder) Ls(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ls", reflect.TypeOf((*MockICloseableFS)(nil).Ls), arg0)
}

// LsFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LsFromOpenedDirectory(arg0 filesystem.File) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsFromOpenedDirectory", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsFromOpenedDirectory indicates an expected call of LsFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LsFromOpenedDirectory(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LsFromOpenedDirectory), arg0)
}

// LsRecursive mocks base method.
func (m *MockICloseableFS) LsRecursive(arg0 context.Context, arg1 string, arg2 bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursive", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursive indicates an expected call of LsRecursive.
func (mr *MockICloseableFSMockRecorder) LsRecursive(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursive", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursive), arg0, arg1, arg2)
}

// LsRecursiveFromOpenedDirectory mocks base method.
func (m *MockICloseableFS) LsRecursiveFromOpenedDirectory(arg0 context.Context, arg1 filesystem.File, arg2 bool) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LsRecursiveFromOpenedDirectory", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveFromOpenedDirectory indicates an expected call of LsRecursiveFromOpenedDirectory.
func (mr *MockICloseableFSMockRecorder) LsRecursiveFromOpenedDirectory(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveFromOpenedDirectory", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveFromOpenedDirectory), arg0, arg1, arg2)
}

// LsRecursiveWithExclusionPatterns mocks base method.
func (m *MockICloseableFS) LsRecursiveWithExclusionPatterns(arg0 context.Context, arg1 string, arg2 bool, arg3 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatterns indicates an expected call of LsRecursiveWithExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) LsRecursiveWithExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveWithExclusionPatterns), varargs...)
}

// LsRecursiveWithExclusionPatternsAndLimits mocks base method.
func (m *MockICloseableFS) LsRecursiveWithExclusionPatternsAndLimits(arg0 context.Context, arg1 string, arg2 filesystem.ILimits, arg3 bool, arg4 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsRecursiveWithExclusionPatternsAndLimits", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsRecursiveWithExclusionPatternsAndLimits indicates an expected call of LsRecursiveWithExclusionPatternsAndLimits.
func (mr *MockICloseableFSMockRecorder) LsRecursiveWithExclusionPatternsAndLimits(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsRecursiveWithExclusionPatternsAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).LsRecursiveWithExclusionPatternsAndLimits), varargs...)
}

// LsWithExclusionPatterns mocks base method.
func (m *MockICloseableFS) LsWithExclusionPatterns(arg0 string, arg1 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LsWithExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LsWithExclusionPatterns indicates an expected call of LsWithExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) LsWithExclusionPatterns(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LsWithExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).LsWithExclusionPatterns), varargs...)
}

// Lstat mocks base method.
func (m *MockICloseableFS) Lstat(arg0 string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lstat", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lstat indicates an expected call of Lstat.
func (mr *MockICloseableFSMockRecorder) Lstat(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lstat", reflect.TypeOf((*MockICloseableFS)(nil).Lstat), arg0)
}

// MkDir mocks base method.
func (m *MockICloseableFS) MkDir(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDir", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDir indicates an expected call of MkDir.
func (mr *MockICloseableFSMockRecorder) MkDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDir", reflect.TypeOf((*MockICloseableFS)(nil).MkDir), arg0)
}

// MkDirAll mocks base method.
func (m *MockICloseableFS) MkDirAll(arg0 string, arg1 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkDirAll", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkDirAll indicates an expected call of MkDirAll.
func (mr *MockICloseableFSMockRecorder) MkDirAll(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkDirAll", reflect.TypeOf((*MockICloseableFS)(nil).MkDirAll), arg0, arg1)
}

// Move mocks base method.
func (m *MockICloseableFS) Move(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Move", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Move indicates an expected call of Move.
func (mr *MockICloseableFSMockRecorder) Move(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Move", reflect.TypeOf((*MockICloseableFS)(nil).Move), arg0, arg1)
}

// MoveWithContext mocks base method.
func (m *MockICloseableFS) MoveWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveWithContext indicates an expected call of MoveWithContext.
func (mr *MockICloseableFSMockRecorder) MoveWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveWithContext", reflect.TypeOf((*MockICloseableFS)(nil).MoveWithContext), arg0, arg1, arg2)
}

// NewRemoteLockFile mocks base method.
func (m *MockICloseableFS) NewRemoteLockFile(arg0, arg1 string) filesystem.ILock {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewRemoteLockFile", arg0, arg1)
	ret0, _ := ret[0].(filesystem.ILock)
	return ret0
}

// NewRemoteLockFile indicates an expected call of NewRemoteLockFile.
func (mr *MockICloseableFSMockRecorder) NewRemoteLockFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewRemoteLockFile", reflect.TypeOf((*MockICloseableFS)(nil).NewRemoteLockFile), arg0, arg1)
}

// Open mocks base method.
func (m *MockICloseableFS) Open(arg0 string) (doublestar.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", arg0)
	ret0, _ := ret[0].(doublestar.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockICloseableFSMockRecorder) Open(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockICloseableFS)(nil).Open), arg0)
}

// OpenFile mocks base method.
func (m *MockICloseableFS) OpenFile(arg0 string, arg1 int, arg2 fs.FileMode) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenFile", arg0, arg1, arg2)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenFile indicates an expected call of OpenFile.
func (mr *MockICloseableFSMockRecorder) OpenFile(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenFile", reflect.TypeOf((*MockICloseableFS)(nil).OpenFile), arg0, arg1, arg2)
}

// PathSeparator mocks base method.
func (m *MockICloseableFS) PathSeparator() int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PathSeparator")
	ret0, _ := ret[0].(int32)
	return ret0
}

// PathSeparator indicates an expected call of PathSeparator.
func (mr *MockICloseableFSMockRecorder) PathSeparator() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathSeparator", reflect.TypeOf((*MockICloseableFS)(nil).PathSeparator))
}

// ReadFile mocks base method.
func (m *MockICloseableFS) ReadFile(arg0 string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockICloseableFSMockRecorder) ReadFile(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockICloseableFS)(nil).ReadFile), arg0)
}

// ReadFileContent mocks base method.
func (m *MockICloseableFS) ReadFileContent(arg0 context.Context, arg1 filesystem.File, arg2 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileContent", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileContent indicates an expected call of ReadFileContent.
func (mr *MockICloseableFSMockRecorder) ReadFileContent(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileContent", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileContent), arg0, arg1, arg2)
}

// ReadFileWithContext mocks base method.
func (m *MockICloseableFS) ReadFileWithContext(arg0 context.Context, arg1 string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContext", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContext indicates an expected call of ReadFileWithContext.
func (mr *MockICloseableFSMockRecorder) ReadFileWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithContext), arg0, arg1)
}

// ReadFileWithContextAndLimits mocks base method.
func (m *MockICloseableFS) ReadFileWithContextAndLimits(arg0 context.Context, arg1 string, arg2 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithContextAndLimits", arg0, arg1, arg2)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithContextAndLimits indicates an expected call of ReadFileWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) ReadFileWithContextAndLimits(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithContextAndLimits), arg0, arg1, arg2)
}

// ReadFileWithLimits mocks base method.
func (m *MockICloseableFS) ReadFileWithLimits(arg0 string, arg1 filesystem.ILimits) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFileWithLimits", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFileWithLimits indicates an expected call of ReadFileWithLimits.
func (mr *MockICloseableFSMockRecorder) ReadFileWithLimits(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFileWithLimits", reflect.TypeOf((*MockICloseableFS)(nil).ReadFileWithLimits), arg0, arg1)
}

// Readlink mocks base method.
func (m *MockICloseableFS) Readlink(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Readlink", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Readlink indicates an expected call of Readlink.
func (mr *MockICloseableFSMockRecorder) Readlink(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Readlink", reflect.TypeOf((*MockICloseableFS)(nil).Readlink), arg0)
}

// RemoveWithContext mocks base method.
func (m *MockICloseableFS) RemoveWithContext(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithContext", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContext indicates an expected call of RemoveWithContext.
func (mr *MockICloseableFSMockRecorder) RemoveWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContext", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithContext), arg0, arg1)
}

// RemoveWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) RemoveWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithContextAndExclusionPatterns indicates an expected call of RemoveWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) RemoveWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithContextAndExclusionPatterns), varargs...)
}

// RemoveWithPrivileges mocks base method.
func (m *MockICloseableFS) RemoveWithPrivileges(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveWithPrivileges", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveWithPrivileges indicates an expected call of RemoveWithPrivileges.
func (mr *MockICloseableFSMockRecorder) RemoveWithPrivileges(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveWithPrivileges", reflect.TypeOf((*MockICloseableFS)(nil).RemoveWithPrivileges), arg0, arg1)
}

// Rm mocks base method.
func (m *MockICloseableFS) Rm(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rm", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rm indicates an expected call of Rm.
func (mr *MockICloseableFSMockRecorder) Rm(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rm", reflect.TypeOf((*MockICloseableFS)(nil).Rm), arg0)
}

// Stat mocks base method.
func (m *MockICloseableFS) Stat(arg0 string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockICloseableFSMockRecorder) Stat(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockICloseableFS)(nil).Stat), arg0)
}

// StatTimes mocks base method.
func (m *MockICloseableFS) StatTimes(arg0 string) (filesystem.FileTimeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatTimes", arg0)
	ret0, _ := ret[0].(filesystem.FileTimeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatTimes indicates an expected call of StatTimes.
func (mr *MockICloseableFSMockRecorder) StatTimes(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatTimes", reflect.TypeOf((*MockICloseableFS)(nil).StatTimes), arg0)
}

// SubDirectories mocks base method.
func (m *MockICloseableFS) SubDirectories(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectories", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectories indicates an expected call of SubDirectories.
func (mr *MockICloseableFSMockRecorder) SubDirectories(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectories", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectories), arg0)
}

// SubDirectoriesWithContext mocks base method.
func (m *MockICloseableFS) SubDirectoriesWithContext(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubDirectoriesWithContext", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContext indicates an expected call of SubDirectoriesWithContext.
func (mr *MockICloseableFSMockRecorder) SubDirectoriesWithContext(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContext", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectoriesWithContext), arg0, arg1)
}

// SubDirectoriesWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) SubDirectoriesWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 ...string) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubDirectoriesWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubDirectoriesWithContextAndExclusionPatterns indicates an expected call of SubDirectoriesWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) SubDirectoriesWithContextAndExclusionPatterns(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubDirectoriesWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).SubDirectoriesWithContextAndExclusionPatterns), varargs...)
}

// Symlink mocks base method.
func (m *MockICloseableFS) Symlink(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Symlink", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Symlink indicates an expected call of Symlink.
func (mr *MockICloseableFSMockRecorder) Symlink(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Symlink", reflect.TypeOf((*MockICloseableFS)(nil).Symlink), arg0, arg1)
}

// TempDir mocks base method.
func (m *MockICloseableFS) TempDir(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDir", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDir indicates an expected call of TempDir.
func (mr *MockICloseableFSMockRecorder) TempDir(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempDir), arg0, arg1)
}

// TempDirInTempDir mocks base method.
func (m *MockICloseableFS) TempDirInTempDir(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirInTempDir", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempDirInTempDir indicates an expected call of TempDirInTempDir.
func (mr *MockICloseableFSMockRecorder) TempDirInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempDirInTempDir), arg0)
}

// TempDirectory mocks base method.
func (m *MockICloseableFS) TempDirectory() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempDirectory")
	ret0, _ := ret[0].(string)
	return ret0
}

// TempDirectory indicates an expected call of TempDirectory.
func (mr *MockICloseableFSMockRecorder) TempDirectory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempDirectory", reflect.TypeOf((*MockICloseableFS)(nil).TempDirectory))
}

// TempFile mocks base method.
func (m *MockICloseableFS) TempFile(arg0, arg1 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFile", arg0, arg1)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFile indicates an expected call of TempFile.
func (mr *MockICloseableFSMockRecorder) TempFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFile", reflect.TypeOf((*MockICloseableFS)(nil).TempFile), arg0, arg1)
}

// TempFileInTempDir mocks base method.
func (m *MockICloseableFS) TempFileInTempDir(arg0 string) (filesystem.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TempFileInTempDir", arg0)
	ret0, _ := ret[0].(filesystem.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TempFileInTempDir indicates an expected call of TempFileInTempDir.
func (mr *MockICloseableFSMockRecorder) TempFileInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TempFileInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TempFileInTempDir), arg0)
}

// Touch mocks base method.
func (m *MockICloseableFS) Touch(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Touch", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Touch indicates an expected call of Touch.
func (mr *MockICloseableFSMockRecorder) Touch(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockICloseableFS)(nil).Touch), arg0)
}

// TouchTempFile mocks base method.
func (m *MockICloseableFS) TouchTempFile(arg0, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFile", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFile indicates an expected call of TouchTempFile.
func (mr *MockICloseableFSMockRecorder) TouchTempFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFile", reflect.TypeOf((*MockICloseableFS)(nil).TouchTempFile), arg0, arg1)
}

// TouchTempFileInTempDir mocks base method.
func (m *MockICloseableFS) TouchTempFileInTempDir(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TouchTempFileInTempDir", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TouchTempFileInTempDir indicates an expected call of TouchTempFileInTempDir.
func (mr *MockICloseableFSMockRecorder) TouchTempFileInTempDir(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TouchTempFileInTempDir", reflect.TypeOf((*MockICloseableFS)(nil).TouchTempFileInTempDir), arg0)
}

// Unzip mocks base method.
func (m *MockICloseableFS) Unzip(arg0, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unzip", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Unzip indicates an expected call of Unzip.
func (mr *MockICloseableFSMockRecorder) Unzip(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unzip", reflect.TypeOf((*MockICloseableFS)(nil).Unzip), arg0, arg1)
}

// UnzipWithContext mocks base method.
func (m *MockICloseableFS) UnzipWithContext(arg0 context.Context, arg1, arg2 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContext indicates an expected call of UnzipWithContext.
func (mr *MockICloseableFSMockRecorder) UnzipWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).UnzipWithContext), arg0, arg1, arg2)
}

// UnzipWithContextAndLimits mocks base method.
func (m *MockICloseableFS) UnzipWithContextAndLimits(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnzipWithContextAndLimits", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnzipWithContextAndLimits indicates an expected call of UnzipWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) UnzipWithContextAndLimits(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnzipWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).UnzipWithContextAndLimits), arg0, arg1, arg2, arg3)
}

// Walk mocks base method.
func (m *MockICloseableFS) Walk(arg0 string, arg1 filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockICloseableFSMockRecorder) Walk(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockICloseableFS)(nil).Walk), arg0, arg1)
}

// WalkWithContext mocks base method.
func (m *MockICloseableFS) WalkWithContext(arg0 context.Context, arg1 string, arg2 filepath.WalkFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WalkWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContext indicates an expected call of WalkWithContext.
func (mr *MockICloseableFSMockRecorder) WalkWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContext", reflect.TypeOf((*MockICloseableFS)(nil).WalkWithContext), arg0, arg1, arg2)
}

// WalkWithContextAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) WalkWithContextAndExclusionPatterns(arg0 context.Context, arg1 string, arg2 filepath.WalkFunc, arg3 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WalkWithContextAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WalkWithContextAndExclusionPatterns indicates an expected call of WalkWithContextAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) WalkWithContextAndExclusionPatterns(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WalkWithContextAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).WalkWithContextAndExclusionPatterns), varargs...)
}

// WriteFile mocks base method.
func (m *MockICloseableFS) WriteFile(arg0 string, arg1 []byte, arg2 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockICloseableFSMockRecorder) WriteFile(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockICloseableFS)(nil).WriteFile), arg0, arg1, arg2)
}

// WriteFileWithContext mocks base method.
func (m *MockICloseableFS) WriteFileWithContext(arg0 context.Context, arg1 string, arg2 []byte, arg3 fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFileWithContext", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFileWithContext indicates an expected call of WriteFileWithContext.
func (mr *MockICloseableFSMockRecorder) WriteFileWithContext(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFileWithContext", reflect.TypeOf((*MockICloseableFS)(nil).WriteFileWithContext), arg0, arg1, arg2, arg3)
}

// WriteToFile mocks base method.
func (m *MockICloseableFS) WriteToFile(arg0 context.Context, arg1 string, arg2 io.Reader, arg3 fs.FileMode) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteToFile", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteToFile indicates an expected call of WriteToFile.
func (mr *MockICloseableFSMockRecorder) WriteToFile(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteToFile", reflect.TypeOf((*MockICloseableFS)(nil).WriteToFile), arg0, arg1, arg2, arg3)
}

// Zip mocks base method.
func (m *MockICloseableFS) Zip(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Zip", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Zip indicates an expected call of Zip.
func (mr *MockICloseableFSMockRecorder) Zip(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Zip", reflect.TypeOf((*MockICloseableFS)(nil).Zip), arg0, arg1)
}

// ZipWithContext mocks base method.
func (m *MockICloseableFS) ZipWithContext(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContext", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContext indicates an expected call of ZipWithContext.
func (mr *MockICloseableFSMockRecorder) ZipWithContext(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContext", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContext), arg0, arg1, arg2)
}

// ZipWithContextAndLimits mocks base method.
func (m *MockICloseableFS) ZipWithContextAndLimits(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZipWithContextAndLimits", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimits indicates an expected call of ZipWithContextAndLimits.
func (mr *MockICloseableFSMockRecorder) ZipWithContextAndLimits(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimits", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContextAndLimits), arg0, arg1, arg2, arg3)
}

// ZipWithContextAndLimitsAndExclusionPatterns mocks base method.
func (m *MockICloseableFS) ZipWithContextAndLimitsAndExclusionPatterns(arg0 context.Context, arg1, arg2 string, arg3 filesystem.ILimits, arg4 ...string) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZipWithContextAndLimitsAndExclusionPatterns", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ZipWithContextAndLimitsAndExclusionPatterns indicates an expected call of ZipWithContextAndLimitsAndExclusionPatterns.
func (mr *MockICloseableFSMockRecorder) ZipWithContextAndLimitsAndExclusionPatterns(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZipWithContextAndLimitsAndExclusionPatterns", reflect.TypeOf((*MockICloseableFS)(nil).ZipWithContextAndLimitsAndExclusionPatterns), varargs...)
}

// MockIForceRemover is a mock of IForceRemover interface.
type MockIForceRemover struct {
	ctrl     *gomock.Controller
	recorder *MockIForceRemoverMockRecorder
}

// MockIForceRemoverMockRecorder is the mock recorder for MockIForceRemover.
type MockIForceRemoverMockRecorder struct {
	mock *MockIForceRemover
}

// NewMockIForceRemover creates a new mock instance.
func NewMockIForceRemover(ctrl *gomock.Controller) *MockIForceRemover {
	mock := &MockIForceRemover{ctrl: ctrl}
	mock.recorder = &MockIForceRemoverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIForceRemover) EXPECT() *MockIForceRemoverMockRecorder {
	return m.recorder
}

// ForceRemoveIfPossible mocks base method.
func (m *MockIForceRemover) ForceRemoveIfPossible(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForceRemoveIfPossible", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ForceRemoveIfPossible indicates an expected call of ForceRemoveIfPossible.
func (mr *MockIForceRemoverMockRecorder) ForceRemoveIfPossible(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForceRemoveIfPossible", reflect.TypeOf((*MockIForceRemover)(nil).ForceRemoveIfPossible), arg0)
}

// MockIStater is a mock of IStater interface.
type MockIStater struct {
	ctrl     *gomock.Controller
	recorder *MockIStaterMockRecorder
}

// MockIStaterMockRecorder is the mock recorder for MockIStater.
type MockIStaterMockRecorder struct {
	mock *MockIStater
}

// NewMockIStater creates a new mock instance.
func NewMockIStater(ctrl *gomock.Controller) *MockIStater {
	mock := &MockIStater{ctrl: ctrl}
	mock.recorder = &MockIStaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStater) EXPECT() *MockIStaterMockRecorder {
	return m.recorder
}

// LstatIfPossible mocks base method.
func (m *MockIStater) LstatIfPossible(arg0 string) (fs.FileInfo, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LstatIfPossible", arg0)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// LstatIfPossible indicates an expected call of LstatIfPossible.
func (mr *MockIStaterMockRecorder) LstatIfPossible(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LstatIfPossible", reflect.TypeOf((*MockIStater)(nil).LstatIfPossible), arg0)
}

// MockILinkReader is a mock of ILinkReader interface.
type MockILinkReader struct {
	ctrl     *gomock.Controller
	recorder *MockILinkReaderMockRecorder
}

// MockILinkReaderMockRecorder is the mock recorder for MockILinkReader.
type MockILinkReaderMockRecorder struct {
	mock *MockILinkReader
}

// NewMockILinkReader creates a new mock instance.
func NewMockILinkReader(ctrl *gomock.Controller) *MockILinkReader {
	mock := &MockILinkReader{ctrl: ctrl}
	mock.recorder = &MockILinkReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockILinkReader) EXPECT() *MockILinkReaderMockRecorder {
	return m.recorder
}

// ReadlinkIfPossible mocks base method.
func (m *MockILinkReader) ReadlinkIfPossible(arg0 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadlinkIfPossible", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadlinkIfPossible indicates an expected call of ReadlinkIfPossible.
func (mr *MockILinkReaderMockRecorder) ReadlinkIfPossible(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadlinkIfPossible", reflect.TypeOf((*MockILinkReader)(nil).ReadlinkIfPossible), arg0)
}

// MockISymLinker is a mock of ISymLinker interface.
type MockISymLinker struct {
	ctrl     *gomock.Controller
	recorder *MockISymLinkerMockRecorder
}

// MockISymLinkerMockRecorder is the mock recorder for MockISymLinker.
type MockISymLinkerMockRecorder struct {
	mock *MockISymLinker
}

// NewMockISymLinker creates a new mock instance.
func NewMockISymLinker(ctrl *gomock.Controller) *MockISymLinker {
	mock := &MockISymLinker{ctrl: ctrl}
	mock.recorder = &MockISymLinkerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISymLinker) EXPECT() *MockISymLinkerMockRecorder {
	return m.recorder
}

// SymlinkIfPossible mocks base method.
func (m *MockISymLinker) SymlinkIfPossible(arg0, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SymlinkIfPossible", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SymlinkIfPossible indicates an expected call of SymlinkIfPossible.
func (mr *MockISymLinkerMockRecorder) SymlinkIfPossible(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SymlinkIfPossible", reflect.TypeOf((*MockISymLinker)(nil).SymlinkIfPossible), arg0, arg1)
}
