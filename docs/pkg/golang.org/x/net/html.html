<!DOCTYPE html>
<!--
-- Copyright (C) 2020-2022 Arm Limited or its affiliates and Contributors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
-->
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: golang.org/x/net/html</title>
<link href="../../../../css/light-v0.4.1.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.4.1.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>html</b></span>

<span class="title">Import Path</span>
	<a href="../../../../index.html#pkg-golang.org/x/net/html">golang.org/x/net/html</a><i> (on <a href="https://pkg.go.dev/golang.org/x/net/html" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../../../../dep/golang.org/x/net/html.html">9 packages</a>, and imported by <a href="../../../../dep/golang.org/x/net/html.html#imported-by">one package</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/const.go.html">const.go</a></span>
	<input type='checkbox' checked class="fold" id="file-1-fold-content"><label for="file-1-fold-content">   <a href="../../../../src/golang.org/x/net/html/doc.go.html#doc">#d</a> <a href="../../../../src/golang.org/x/net/html/doc.go.html">doc.go</a></label><span id='file-1-fold-content-items' class="fold-items">
		Package html implements an HTML5-compliant tokenizer and parser.

		Tokenization is done by creating a Tokenizer for an io.Reader r. It is the
		caller's responsibility to ensure that r provides UTF-8 encoded HTML.

		z := html.NewTokenizer(r)

		Given a Tokenizer z, the HTML is tokenized by repeatedly calling z.Next(),
		which parses the next token and returns its type, or an error:

		for {
			tt := z.Next()
			if tt == html.ErrorToken {
				// ...
				return ...
			}
			// Process the current token.
		}

		There are two APIs for retrieving the current token. The high-level API is to
		call Token; the low-level API is to call Text or TagName / TagAttr. Both APIs
		allow optionally calling Raw after Next but before Token, Text, TagName, or
		TagAttr. In EBNF notation, the valid call sequence per token is:

		Next {Raw} [ Token | Text | TagName {TagAttr} ]

		Token returns an independent data structure that completely describes a token.
		Entities (such as "&amp;lt;") are unescaped, tag names and attribute keys are
		lower-cased, and attributes are collected into a []Attribute. For example:

		for {
			if z.Next() == html.ErrorToken {
				// Returning io.EOF indicates success.
				return z.Err()
			}
			emitToken(z.Token())
		}

		The low-level API performs fewer allocations and copies, but the contents of
		the []byte values returned by Text, TagName and TagAttr may change on the next
		call to Next. For example, to extract an HTML page's anchor text:

		depth := 0
		for {
			tt := z.Next()
			switch tt {
			case html.ErrorToken:
				return z.Err()
			case html.TextToken:
				if depth &gt; 0 {
					// emitBytes should copy the []byte it receives,
					// if it doesn't process it immediately.
					emitBytes(z.Text())
				}
			case html.StartTagToken, html.EndTagToken:
				tn, _ := z.TagName()
				if len(tn) == 1 &amp;&amp; tn[0] == 'a' {
					if tt == html.StartTagToken {
						depth++
					} else {
						depth--
					}
				}
			}
		}

		Parsing is done by calling Parse with an io.Reader, which returns the root of
		the parse tree (the document element) as a *Node. It is the caller's
		responsibility to ensure that the Reader provides UTF-8 encoded HTML. For
		example, to process each anchor node in depth-first order:

		doc, err := html.Parse(r)
		if err != nil {
			// ...
		}
		var f func(*html.Node)
		f = func(n *html.Node) {
			if n.Type == html.ElementNode &amp;&amp; n.Data == "a" {
				// Do something with n...
			}
			for c := n.FirstChild; c != nil; c = c.NextSibling {
				f(c)
			}
		}
		f(doc)

		The relevant specifications include:
		https://html.spec.whatwg.org/multipage/syntax.html and
		https://html.spec.whatwg.org/multipage/syntax.html#tokenization
</span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/doctype.go.html">doctype.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/entity.go.html">entity.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/escape.go.html">escape.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/foreign.go.html">foreign.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/node.go.html">node.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/parse.go.html">parse.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/render.go.html">render.go</a></span>
	<span class="nodocs">      <a href="../../../../src/golang.org/x/net/html/token.go.html">token.go</a></span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content">Parse</label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"golang.org/x/net/html"
			"log"
			"strings"
		)
		
		func main() {
			s := `&lt;p&gt;Links:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="foo"&gt;Foo&lt;/a&gt;&lt;li&gt;&lt;a href="/bar/baz"&gt;BarBaz&lt;/a&gt;&lt;/ul&gt;`
			doc, err := html.Parse(strings.NewReader(s))
			if err != nil {
				log.Fatal(err)
			}
			var f func(*html.Node)
			f = func(n *html.Node) {
				if n.Type == html.ElementNode &amp;&amp; n.Data == "a" {
					for _, a := range n.Attr {
						if a.Key == "href" {
							fmt.Println(a.Val)
							break
						}
					}
				}
				for c := n.FirstChild; c != nil; c = c.NextSibling {
					f(c)
				}
			}
			f(doc)
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (total 7)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Attribute" data-popularity="0">	<input type='checkbox' class="fold" id="Attribute-fold-content"><label for="Attribute-fold-content"> type <a href="../../../../src/golang.org/x/net/html/token.go.html#line-67">Attribute</a> <i>(struct)</i></label><span id='Attribute-fold-content-docs' class="fold-docs">
		An Attribute is an attribute namespace-key-value triple. Namespace is
		non-empty for foreign attributes like xlink, Key is alphabetic (and hence
		does not contain escapable characters like '&amp;', '&lt;' or '&gt;'), and Val is
		unescaped (it looks like "a&lt;b" rather than "a&amp;lt;b").

		Namespace is only used by the parser, not the tokenizer.

		<input type='checkbox' class="fold" id="Attribute-fold-fields"><label for="Attribute-fold-fields">Fields (<i>total 3</i>)</label><span id='Attribute-fold-fields-items' class="fold-items"><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-68">Key</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-68">Namespace</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-68">Val</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span></span>

</span></div><div class="anchor type-res" id="name-Node" data-popularity="660">	<input type='checkbox' class="fold" id="Node-fold-content"><label for="Node-fold-content"> type <a href="../../../../src/golang.org/x/net/html/node.go.html#line-44">Node</a> <i>(struct)</i></label><span id='Node-fold-content-docs' class="fold-docs">
		A Node consists of a NodeType and some Data (tag name for element nodes,
		content for text) and are part of a tree of Nodes. Element nodes may also
		have a Namespace and contain a slice of Attributes. Data is unescaped, so
		that it looks like "a&lt;b" rather than "a&amp;lt;b". For element nodes, DataAtom
		is the atom for Data, or zero if Data is not a known tag name.

		An empty Namespace implies a "http://www.w3.org/1999/xhtml" namespace.
		Similarly, "math" is short for "http://www.w3.org/1998/Math/MathML", and
		"svg" is short for "http://www.w3.org/2000/svg".

		<input type='checkbox' class="fold" id="Node-fold-fields"><label for="Node-fold-fields">Fields (<i>total 10</i>)</label><span id='Node-fold-fields-items' class="fold-items"><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-51">Attr</a> <i>[]<a href="#name-Attribute">Attribute</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-49">Data</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-48">DataAtom</a> <i><a href="html/atom.html">atom</a>.<a href="html/atom.html#name-Atom">Atom</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-45">FirstChild</a> <i>*<b>Node</b></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-45">LastChild</a> <i>*<b>Node</b></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-50">Namespace</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-45">NextSibling</a> <i>*<b>Node</b></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-45">Parent</a> <i>*<b>Node</b></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-45">PrevSibling</a> <i>*<b>Node</b></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/node.go.html#line-47">Type</a> <i><a href="#name-NodeType">NodeType</a></i></span></span></span>
		<input type='checkbox' class="fold" id="Node-fold-methods"><label for="Node-fold-methods">Methods (<i>total 3</i>)</label><span id='Node-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Node-fold-method-AppendChild"><label for="Node-fold-method-AppendChild">(*T) <a href="../../../../src/golang.org/x/net/html/node.go.html#line-87">AppendChild</a>(c *<b>Node</b>)</label><span id='Node-fold-method-AppendChild-docs' class="fold-docs">
				AppendChild adds a node c as a child of n.

				It will panic if c already has a parent or siblings.
</span></span><span>
			<input type='checkbox' class="fold" id="Node-fold-method-InsertBefore"><label for="Node-fold-method-InsertBefore">(*T) <a href="../../../../src/golang.org/x/net/html/node.go.html#line-59">InsertBefore</a>(newChild, oldChild *<b>Node</b>)</label><span id='Node-fold-method-InsertBefore-docs' class="fold-docs">
				InsertBefore inserts newChild as a child of n, immediately before oldChild
				in the sequence of n's children. oldChild may be nil, in which case newChild
				is appended to the end of n's children.

				It will panic if newChild already has a parent or siblings.
</span></span><span>
			<input type='checkbox' class="fold" id="Node-fold-method-RemoveChild"><label for="Node-fold-method-RemoveChild">(*T) <a href="../../../../src/golang.org/x/net/html/node.go.html#line-106">RemoveChild</a>(c *<b>Node</b>)</label><span id='Node-fold-method-RemoveChild-docs' class="fold-docs">
				RemoveChild removes a node c that is a child of n. Afterwards, c will have
				no parent and no siblings.

				It will panic if c's parent is not n.
</span></span></span>
		<input type='checkbox' class="fold" id="Node-fold-results"><label for="Node-fold-results">As Outputs Of (<i>at least 4</i>)</label><span id='Node-fold-results-items' class="fold-items"><span>
			func <a href="#name-Parse">Parse</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>) (*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-ParseFragment">ParseFragment</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<b>Node</b>) ([]*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-ParseFragmentWithOptions">ParseFragmentWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<b>Node</b>, opts ...<a href="#name-ParseOption">ParseOption</a>) ([]*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-ParseWithOptions">ParseWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, opts ...<a href="#name-ParseOption">ParseOption</a>) (*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span></span>
		<input type='checkbox' class="fold" id="Node-fold-params"><label for="Node-fold-params">As Inputs Of (<i>at least 6</i>)</label><span id='Node-fold-params-items' class="fold-items"><span>
			func <a href="#name-ParseFragment">ParseFragment</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<b>Node</b>) ([]*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-ParseFragmentWithOptions">ParseFragmentWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<b>Node</b>, opts ...<a href="#name-ParseOption">ParseOption</a>) ([]*<b>Node</b>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-Render">Render</a>(w <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Writer">Writer</a>, n *<b>Node</b>) <a href="../../../builtin.html#name-error">error</a></span><span>
			func (*Node).<a href="../../../../src/golang.org/x/net/html/node.go.html#line-87">AppendChild</a>(c *<b>Node</b>)</span><span>
			func (*Node).<a href="../../../../src/golang.org/x/net/html/node.go.html#line-59">InsertBefore</a>(newChild, oldChild *<b>Node</b>)</span><span>
			func (*Node).<a href="../../../../src/golang.org/x/net/html/node.go.html#line-106">RemoveChild</a>(c *<b>Node</b>)</span></span>

</span></div><div class="anchor type-res" id="name-NodeType" data-popularity="15">	<input type='checkbox' class="fold" id="NodeType-fold-content"><label for="NodeType-fold-content"> type <a href="../../../../src/golang.org/x/net/html/node.go.html#line-12">NodeType</a> <a href="../../../builtin.html#name-uint32">uint32</a> <i>(basic type)</i></label><span id='NodeType-fold-content-docs' class="fold-docs">
		A NodeType is the type of a Node.

		<input type='checkbox' class="fold" id="NodeType-fold-values"><label for="NodeType-fold-values">As Types Of (<i>total 7</i>)</label><span id='NodeType-fold-values-items' class="fold-items"><span>
			const <a href="#name-CommentNode">CommentNode</a></span><span>
			const <a href="#name-DoctypeNode">DoctypeNode</a></span><span>
			const <a href="#name-DocumentNode">DocumentNode</a></span><span>
			const <a href="#name-ElementNode">ElementNode</a></span><span>
			const <a href="#name-ErrorNode">ErrorNode</a></span><span>
			const <a href="#name-RawNode">RawNode</a></span><span>
			const <a href="#name-TextNode">TextNode</a></span></span>

</span></div><div class="anchor type-res" id="name-ParseOption" data-popularity="145">	<input type='checkbox' class="fold" id="ParseOption-fold-content"><label for="ParseOption-fold-content"> type <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2357">ParseOption</a> <i>(func)</i></label><span id='ParseOption-fold-content-docs' class="fold-docs">
		ParseOption configures a parser.

		<input type='checkbox' class="fold" id="ParseOption-fold-results"><label for="ParseOption-fold-results">As Outputs Of (<i>at least one exported</i>)</label><span id='ParseOption-fold-results-items' class="fold-items"><span>
			func <a href="#name-ParseOptionEnableScripting">ParseOptionEnableScripting</a>(enable <a href="../../../builtin.html#name-bool">bool</a>) <b>ParseOption</b></span></span>
		<input type='checkbox' class="fold" id="ParseOption-fold-params"><label for="ParseOption-fold-params">As Inputs Of (<i>at least 2</i>)</label><span id='ParseOption-fold-params-items' class="fold-items"><span>
			func <a href="#name-ParseFragmentWithOptions">ParseFragmentWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<a href="#name-Node">Node</a>, opts ...<b>ParseOption</b>) ([]*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-ParseWithOptions">ParseWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, opts ...<b>ParseOption</b>) (*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</span></span>

</span></div><div class="anchor type-res" id="name-Token" data-popularity="175">	<input type='checkbox' class="fold" id="Token-fold-content"><label for="Token-fold-content"> type <a href="../../../../src/golang.org/x/net/html/token.go.html#line-76">Token</a> <i>(struct)</i></label><span id='Token-fold-content-docs' class="fold-docs">
		A Token consists of a TokenType and some Data (tag name for start and end
		tags, content for text, comments and doctypes). A tag Token may also contain
		a slice of Attributes. Data is unescaped for all Tokens (it looks like "a&lt;b"
		rather than "a&amp;lt;b"). For tag Tokens, DataAtom is the atom for Data, or
		zero if Data is not a known tag name.

		<input type='checkbox' class="fold" id="Token-fold-fields"><label for="Token-fold-fields">Fields (<i>total 4</i>)</label><span id='Token-fold-fields-items' class="fold-items"><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-80">Attr</a> <i>[]<a href="#name-Attribute">Attribute</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-79">Data</a> <i><a href="../../../builtin.html#name-string">string</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-78">DataAtom</a> <i><a href="html/atom.html">atom</a>.<a href="html/atom.html#name-Atom">Atom</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../src/golang.org/x/net/html/token.go.html#line-77">Type</a> <i><a href="#name-TokenType">TokenType</a></i></span></span></span>
		<input type='checkbox' class="fold" id="Token-fold-methods"><label for="Token-fold-methods">Methods (<i>only one</i>)</label><span id='Token-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Token-fold-method-String"><label for="Token-fold-method-String">( T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-100">String</a>() <a href="../../../builtin.html#name-string">string</a></label><span id='Token-fold-method-String-docs' class="fold-docs">
				String returns a string representation of the Token.
</span></span></span>
		<input type='checkbox' class="fold" id="Token-fold-impls"><label for="Token-fold-impls">Implements (<i>at least one exported</i>)</label><span id='Token-fold-impls-items' class="fold-items"><span>
			 T : fmt.<a href="../../../fmt.html#name-Stringer">Stringer</a></span></span>
		<input type='checkbox' class="fold" id="Token-fold-results"><label for="Token-fold-results">As Outputs Of (<i>at least one exported</i>)</label><span id='Token-fold-results-items' class="fold-items"><span>
			func (*<a href="#name-Tokenizer">Tokenizer</a>).<a href="../../../../src/golang.org/x/net/html/token.go.html#line-1171">Token</a>() <b>Token</b></span></span>

</span></div><div class="anchor type-res" id="name-Tokenizer" data-popularity="700">	<input type='checkbox' class="fold" id="Tokenizer-fold-content"><label for="Tokenizer-fold-content"> type <a href="../../../../src/golang.org/x/net/html/token.go.html#line-127">Tokenizer</a> <i>(struct)</i></label><span id='Tokenizer-fold-content-docs' class="fold-docs">
		A Tokenizer returns a stream of HTML Tokens.

		<input type='checkbox' class="fold" id="Tokenizer-fold-methods"><label for="Tokenizer-fold-methods">Methods (<i>total 11</i>)</label><span id='Tokenizer-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-AllowCDATA"><label for="Tokenizer-fold-method-AllowCDATA">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-188">AllowCDATA</a>(allowCDATA <a href="../../../builtin.html#name-bool">bool</a>)</label><span id='Tokenizer-fold-method-AllowCDATA-docs' class="fold-docs">
				AllowCDATA sets whether or not the tokenizer recognizes &lt;![CDATA[foo]]&gt; as
				the text "foo". The default value is false, which means to recognize it as
				a bogus comment "&lt;!-- [CDATA[foo]] --&gt;" instead.

				Strictly speaking, an HTML5 compliant tokenizer should allow CDATA if and
				only if tokenizing foreign content, such as MathML and SVG. However,
				tracking foreign-contentness is difficult to do purely in the tokenizer,
				as opposed to the parser, due to HTML integration points: an &lt;svg&gt; element
				can contain a &lt;foreignObject&gt; that is foreign-to-SVG but not foreign-to-
				HTML. For strict compliance with the HTML5 tokenization algorithm, it is the
				responsibility of the user of a tokenizer to call AllowCDATA as appropriate.
				In practice, if using the tokenizer without caring whether MathML or SVG
				CDATA is text or comments, such as tokenizing HTML to find all the anchor
				text, it is acceptable to ignore this responsibility.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Buffered"><label for="Tokenizer-fold-method-Buffered">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-290">Buffered</a>() []<a href="../../../builtin.html#name-byte">byte</a></label><span id='Tokenizer-fold-method-Buffered-docs' class="fold-docs">
				Buffered returns a slice containing data buffered but not yet tokenized.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Err"><label for="Tokenizer-fold-method-Err">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-222">Err</a>() <a href="../../../builtin.html#name-error">error</a></label><span id='Tokenizer-fold-method-Err-docs' class="fold-docs">
				Err returns the error associated with the most recent ErrorToken token.
				This is typically io.EOF, meaning the end of tokenization.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Next"><label for="Tokenizer-fold-method-Next">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-950">Next</a>() <a href="#name-TokenType">TokenType</a></label><span id='Tokenizer-fold-method-Next-docs' class="fold-docs">
				Next scans the next token and returns its type.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-NextIsNotRawText"><label for="Tokenizer-fold-method-NextIsNotRawText">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-216">NextIsNotRawText</a>()</label><span id='Tokenizer-fold-method-NextIsNotRawText-docs' class="fold-docs">
				NextIsNotRawText instructs the tokenizer that the next token should not be
				considered as 'raw text'. Some elements, such as script and title elements,
				normally require the next token after the opening tag to be 'raw text' that
				has no child elements. For example, tokenizing "&lt;title&gt;a&lt;b&gt;c&lt;/b&gt;d&lt;/title&gt;"
				yields a start tag token for "&lt;title&gt;", a text token for "a&lt;b&gt;c&lt;/b&gt;d", and
				an end tag token for "&lt;/title&gt;". There are no distinct start tag or end tag
				tokens for the "&lt;b&gt;" and "&lt;/b&gt;".

				This tokenizer implementation will generally look for raw text at the right
				times. Strictly speaking, an HTML5 compliant tokenizer should not look for
				raw text if in foreign content: &lt;title&gt; generally needs raw text, but a
				&lt;title&gt; inside an &lt;svg&gt; does not. Another example is that a &lt;textarea&gt;
				generally needs raw text, but a &lt;textarea&gt; is not allowed as an immediate
				child of a &lt;select&gt;; in normal parsing, a &lt;textarea&gt; implies &lt;/select&gt;, but
				one cannot close the implicit element when parsing a &lt;select&gt;'s InnerHTML.
				Similarly to AllowCDATA, tracking the correct moment to override raw-text-
				ness is difficult to do purely in the tokenizer, as opposed to the parser.
				For strict compliance with the HTML5 tokenization algorithm, it is the
				responsibility of the user of a tokenizer to call NextIsNotRawText as
				appropriate. In practice, like AllowCDATA, it is acceptable to ignore this
				responsibility for basic usage.

				Note that this 'raw text' concept is different from the one offered by the
				Tokenizer.Raw method.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Raw"><label for="Tokenizer-fold-method-Raw">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1075">Raw</a>() []<a href="../../../builtin.html#name-byte">byte</a></label><span id='Tokenizer-fold-method-Raw-docs' class="fold-docs">
				Raw returns the unmodified text of the current token. Calling Next, Token,
				Text, TagName or TagAttr may change the contents of the returned slice.

				The token stream's raw bytes partition the byte stream (up until an
				ErrorToken). There are no overlaps or gaps between two consecutive token's
				raw bytes. One implication is that the byte offset of the current token is
				the sum of the lengths of all previous tokens' raw bytes.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-SetMaxBuf"><label for="Tokenizer-fold-method-SetMaxBuf">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1194">SetMaxBuf</a>(n <a href="../../../builtin.html#name-int">int</a>)</label><span id='Tokenizer-fold-method-SetMaxBuf-docs' class="fold-docs">
				SetMaxBuf sets a limit on the amount of data buffered during tokenization.
				A value of 0 means unlimited.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-TagAttr"><label for="Tokenizer-fold-method-TagAttr">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1155">TagAttr</a>() (key, val []<a href="../../../builtin.html#name-byte">byte</a>, moreAttr <a href="../../../builtin.html#name-bool">bool</a>)</label><span id='Tokenizer-fold-method-TagAttr-docs' class="fold-docs">
				TagAttr returns the lower-cased key and unescaped value of the next unparsed
				attribute for the current tag token and whether there are more attributes.
				The contents of the returned slices may change on the next call to Next.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-TagName"><label for="Tokenizer-fold-method-TagName">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1139">TagName</a>() (name []<a href="../../../builtin.html#name-byte">byte</a>, hasAttr <a href="../../../builtin.html#name-bool">bool</a>)</label><span id='Tokenizer-fold-method-TagName-docs' class="fold-docs">
				TagName returns the lower-cased name of a tag token (the `img` out of
				`&lt;IMG SRC="foo"&gt;`) and whether the tag has attributes.
				The contents of the returned slice may change on the next call to Next.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Text"><label for="Tokenizer-fold-method-Text">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1118">Text</a>() []<a href="../../../builtin.html#name-byte">byte</a></label><span id='Tokenizer-fold-method-Text-docs' class="fold-docs">
				Text returns the unescaped text of a text, comment or doctype token. The
				contents of the returned slice may change on the next call to Next.
</span></span><span>
			<input type='checkbox' class="fold" id="Tokenizer-fold-method-Token"><label for="Tokenizer-fold-method-Token">(*T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1171">Token</a>() <a href="#name-Token">Token</a></label><span id='Tokenizer-fold-method-Token-docs' class="fold-docs">
				Token returns the current Token. The result's Data and Attr values remain
				valid after subsequent Next calls.
</span></span></span>
		<input type='checkbox' class="fold" id="Tokenizer-fold-results"><label for="Tokenizer-fold-results">As Outputs Of (<i>at least 2</i>)</label><span id='Tokenizer-fold-results-items' class="fold-items"><span>
			func <a href="#name-NewTokenizer">NewTokenizer</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>) *<b>Tokenizer</b></span><span>
			func <a href="#name-NewTokenizerFragment">NewTokenizerFragment</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, contextTag <a href="../../../builtin.html#name-string">string</a>) *<b>Tokenizer</b></span></span>

</span></div><div class="anchor type-res" id="name-TokenType" data-popularity="190">	<input type='checkbox' class="fold" id="TokenType-fold-content"><label for="TokenType-fold-content"> type <a href="../../../../src/golang.org/x/net/html/token.go.html#line-18">TokenType</a> <a href="../../../builtin.html#name-uint32">uint32</a> <i>(basic type)</i></label><span id='TokenType-fold-content-docs' class="fold-docs">
		A TokenType is the type of a Token.

		<input type='checkbox' class="fold" id="TokenType-fold-methods"><label for="TokenType-fold-methods">Methods (<i>only one</i>)</label><span id='TokenType-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="TokenType-fold-method-String"><label for="TokenType-fold-method-String">( T) <a href="../../../../src/golang.org/x/net/html/token.go.html#line-41">String</a>() <a href="../../../builtin.html#name-string">string</a></label><span id='TokenType-fold-method-String-docs' class="fold-docs">
				String returns a string representation of the TokenType.
</span></span></span>
		<input type='checkbox' class="fold" id="TokenType-fold-impls"><label for="TokenType-fold-impls">Implements (<i>at least one exported</i>)</label><span id='TokenType-fold-impls-items' class="fold-items"><span>
			 T : fmt.<a href="../../../fmt.html#name-Stringer">Stringer</a></span></span>
		<input type='checkbox' class="fold" id="TokenType-fold-results"><label for="TokenType-fold-results">As Outputs Of (<i>at least one exported</i>)</label><span id='TokenType-fold-results-items' class="fold-items"><span>
			func (*<a href="#name-Tokenizer">Tokenizer</a>).<a href="../../../../src/golang.org/x/net/html/token.go.html#line-950">Next</a>() <b>TokenType</b></span></span>
		<input type='checkbox' class="fold" id="TokenType-fold-values"><label for="TokenType-fold-values">As Types Of (<i>total 7</i>)</label><span id='TokenType-fold-values-items' class="fold-items"><span>
			const <a href="#name-CommentToken">CommentToken</a></span><span>
			const <a href="#name-DoctypeToken">DoctypeToken</a></span><span>
			const <a href="#name-EndTagToken">EndTagToken</a></span><span>
			const <a href="#name-ErrorToken">ErrorToken</a></span><span>
			const <a href="#name-SelfClosingTagToken">SelfClosingTagToken</a></span><span>
			const <a href="#name-StartTagToken">StartTagToken</a></span><span>
			const <a href="#name-TextToken">TextToken</a></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 10)</i></span></span>

<div class="anchor value-res" id="name-EscapeString">	<input type='checkbox' class="fold" id="EscapeString-fold-content"><label for="EscapeString-fold-content"> func <a href="../../../../src/golang.org/x/net/html/escape.go.html#line-237">EscapeString</a>(s <a href="../../../builtin.html#name-string">string</a>) <a href="../../../builtin.html#name-string">string</a></label><span id='EscapeString-fold-content-docs' class="fold-docs">
		EscapeString escapes special characters like "&lt;" to become "&amp;lt;". It
		escapes only five such characters: &lt;, &gt;, &amp;, ' and ".
		UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
		always true.

</span></div><div class="anchor value-res" id="name-NewTokenizer">	<input type='checkbox' class="fold" id="NewTokenizer-fold-content"><label for="NewTokenizer-fold-content"> func <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1200">NewTokenizer</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>) *<a href="#name-Tokenizer">Tokenizer</a></label><span id='NewTokenizer-fold-content-docs' class="fold-docs">
		NewTokenizer returns a new HTML Tokenizer for the given Reader.
		The input is assumed to be UTF-8 encoded.

</span></div><div class="anchor value-res" id="name-NewTokenizerFragment">	<input type='checkbox' class="fold" id="NewTokenizerFragment-fold-content"><label for="NewTokenizerFragment-fold-content"> func <a href="../../../../src/golang.org/x/net/html/token.go.html#line-1212">NewTokenizerFragment</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, contextTag <a href="../../../builtin.html#name-string">string</a>) *<a href="#name-Tokenizer">Tokenizer</a></label><span id='NewTokenizerFragment-fold-content-docs' class="fold-docs">
		NewTokenizerFragment returns a new HTML Tokenizer for the given Reader, for
		tokenizing an existing element's InnerHTML fragment. contextTag is that
		element's tag, such as "div" or "iframe".

		For example, how the InnerHTML "a&lt;b" is tokenized depends on whether it is
		for a &lt;p&gt; tag or a &lt;script&gt; tag.

		The input is assumed to be UTF-8 encoded.

</span></div><div class="anchor value-res" id="name-Parse">	<input type='checkbox' class="fold" id="Parse-fold-content"><label for="Parse-fold-content"> func <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2343">Parse</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>) (*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</label><span id='Parse-fold-content-docs' class="fold-docs">
		Parse returns the parse tree for the HTML from the given Reader.

		It implements the HTML5 parsing algorithm
		(https://html.spec.whatwg.org/multipage/syntax.html#tree-construction),
		which is very complicated. The resultant tree can contain implicitly created
		nodes that have no explicit &lt;tag&gt; listed in r's data, and nodes' parents can
		differ from the nesting implied by a naive processing of start and end
		&lt;tag&gt;s. Conversely, explicit &lt;tag&gt;s in r's data can be silently dropped,
		with no corresponding node in the resulting tree.

		The input is assumed to be UTF-8 encoded.

</span></div><div class="anchor value-res" id="name-ParseFragment">	<input type='checkbox' class="fold" id="ParseFragment-fold-content"><label for="ParseFragment-fold-content"> func <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2352">ParseFragment</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<a href="#name-Node">Node</a>) ([]*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</label><span id='ParseFragment-fold-content-docs' class="fold-docs">
		ParseFragment parses a fragment of HTML and returns the nodes that were
		found. If the fragment is the InnerHTML for an existing element, pass that
		element in context.

		It has the same intricacies as Parse.

</span></div><div class="anchor value-res" id="name-ParseFragmentWithOptions">	<input type='checkbox' class="fold" id="ParseFragmentWithOptions-fold-content"><label for="ParseFragmentWithOptions-fold-content"> func <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2392">ParseFragmentWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, context *<a href="#name-Node">Node</a>, opts ...<a href="#name-ParseOption">ParseOption</a>) ([]*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</label><span id='ParseFragmentWithOptions-fold-content-docs' class="fold-docs">
		ParseFragmentWithOptions is like ParseFragment, with options.

</span></div><div class="anchor value-res" id="name-ParseOptionEnableScripting">	<input type='checkbox' class="fold" id="ParseOptionEnableScripting-fold-content"><label for="ParseOptionEnableScripting-fold-content"> func <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2363">ParseOptionEnableScripting</a>(enable <a href="../../../builtin.html#name-bool">bool</a>) <a href="#name-ParseOption">ParseOption</a></label><span id='ParseOptionEnableScripting-fold-content-docs' class="fold-docs">
		ParseOptionEnableScripting configures the scripting flag.
		https://html.spec.whatwg.org/multipage/webappapis.html#enabling-and-disabling-scripting

		By default, scripting is enabled.

</span></div><div class="anchor value-res" id="name-ParseWithOptions">	<input type='checkbox' class="fold" id="ParseWithOptions-fold-content"><label for="ParseWithOptions-fold-content"> func <a href="../../../../src/golang.org/x/net/html/parse.go.html#line-2370">ParseWithOptions</a>(r <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Reader">Reader</a>, opts ...<a href="#name-ParseOption">ParseOption</a>) (*<a href="#name-Node">Node</a>, <a href="../../../builtin.html#name-error">error</a>)</label><span id='ParseWithOptions-fold-content-docs' class="fold-docs">
		ParseWithOptions is like Parse, with options.

</span></div><div class="anchor value-res" id="name-Render">	<input type='checkbox' class="fold" id="Render-fold-content"><label for="Render-fold-content"> func <a href="../../../../src/golang.org/x/net/html/render.go.html#line-45">Render</a>(w <a href="../../../io.html">io</a>.<a href="../../../io.html#name-Writer">Writer</a>, n *<a href="#name-Node">Node</a>) <a href="../../../builtin.html#name-error">error</a></label><span id='Render-fold-content-docs' class="fold-docs">
		Render renders the parse tree n to the given writer.

		Rendering is done on a 'best effort' basis: calling Parse on the output of
		Render will always result in something similar to the original tree, but it
		is not necessarily an exact clone unless the original tree was 'well-formed'.
		'Well-formed' is not easily specified; the HTML5 specification is
		complicated.

		Calling Parse on arbitrary input typically results in a 'well-formed' parse
		tree. However, it is possible for Parse to yield a 'badly-formed' parse tree.
		For example, in a 'well-formed' parse tree, no &lt;a&gt; element is a child of
		another &lt;a&gt; element: parsing "&lt;a&gt;&lt;a&gt;" results in two sibling elements.
		Similarly, in a 'well-formed' parse tree, no &lt;a&gt; element is a child of a
		&lt;table&gt; element: parsing "&lt;p&gt;&lt;table&gt;&lt;a&gt;" results in a &lt;p&gt; with two sibling
		children; the &lt;a&gt; is reparented to the &lt;table&gt;'s parent. However, calling
		Parse on "&lt;a&gt;&lt;table&gt;&lt;a&gt;" does not return an error, but the result has an &lt;a&gt;
		element with an &lt;a&gt; child, and is therefore not 'well-formed'.

		Programmatically constructed trees are typically also 'well-formed', but it
		is possible to construct a tree that looks innocuous but, when rendered and
		re-parsed, results in a different tree. A simple example is that a solitary
		text node would become a tree containing &lt;html&gt;, &lt;head&gt; and &lt;body&gt; elements.
		Another example is that the programmatic equivalent of "a&lt;head&gt;b&lt;/head&gt;c"
		becomes "&lt;html&gt;&lt;head&gt;&lt;head/&gt;&lt;body&gt;abc&lt;/body&gt;&lt;/html&gt;".

</span></div><div class="anchor value-res" id="name-UnescapeString">	<input type='checkbox' class="fold" id="UnescapeString-fold-content"><label for="UnescapeString-fold-content"> func <a href="../../../../src/golang.org/x/net/html/escape.go.html#line-251">UnescapeString</a>(s <a href="../../../builtin.html#name-string">string</a>) <a href="../../../builtin.html#name-string">string</a></label><span id='UnescapeString-fold-content-docs' class="fold-docs">
		UnescapeString unescapes entities like "&amp;lt;" to become "&lt;". It unescapes a
		larger range of entities than EscapeString escapes. For example, "&amp;aacute;"
		unescapes to "รก", as does "&amp;#225;" and "&amp;xE1;".
		UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
		always true.

</span></div></div>
<div id="exported-variables"><span class="title">Package-Level Variables<span class="title-stat"><i> (only one)</i></span></span>

<div class="anchor value-res" id="name-ErrBufferExceeded">	<input type='checkbox' class="fold" id="ErrBufferExceeded-fold-content"><label for="ErrBufferExceeded-fold-content">  var <a href="../../../../src/golang.org/x/net/html/token.go.html#line-38">ErrBufferExceeded</a> <a href="../../../builtin.html#name-error">error</a></label><span id='ErrBufferExceeded-fold-content-docs' class="fold-docs">
		ErrBufferExceeded means that the buffering limit was exceeded.

</span></div></div>
<div id="exported-constants"><span class="title">Package-Level Constants<span class="title-stat"><i> (total 14)</i></span></span>

<div class="anchor value-res" id="name-CommentNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-19">CommentNode</a> <a href="#name-NodeType">NodeType</a> = 4</span></div><div class="anchor value-res" id="name-CommentToken">	<input type='checkbox' class="fold" id="CommentToken-fold-content"><label for="CommentToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-32">CommentToken</a> <a href="#name-TokenType">TokenType</a> = 5</label><span id='CommentToken-fold-content-docs' class="fold-docs">
		A CommentToken looks like &lt;!--x--&gt;.

</span></div><div class="anchor value-res" id="name-DoctypeNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-20">DoctypeNode</a> <a href="#name-NodeType">NodeType</a> = 5</span></div><div class="anchor value-res" id="name-DoctypeToken">	<input type='checkbox' class="fold" id="DoctypeToken-fold-content"><label for="DoctypeToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-34">DoctypeToken</a> <a href="#name-TokenType">TokenType</a> = 6</label><span id='DoctypeToken-fold-content-docs' class="fold-docs">
		A DoctypeToken looks like &lt;!DOCTYPE x&gt;

</span></div><div class="anchor value-res" id="name-DocumentNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-17">DocumentNode</a> <a href="#name-NodeType">NodeType</a> = 2</span></div><div class="anchor value-res" id="name-ElementNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-18">ElementNode</a> <a href="#name-NodeType">NodeType</a> = 3</span></div><div class="anchor value-res" id="name-EndTagToken">	<input type='checkbox' class="fold" id="EndTagToken-fold-content"><label for="EndTagToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-28">EndTagToken</a> <a href="#name-TokenType">TokenType</a> = 3</label><span id='EndTagToken-fold-content-docs' class="fold-docs">
		An EndTagToken looks like &lt;/a&gt;.

</span></div><div class="anchor value-res" id="name-ErrorNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-15">ErrorNode</a> <a href="#name-NodeType">NodeType</a> = 0</span></div><div class="anchor value-res" id="name-ErrorToken">	<input type='checkbox' class="fold" id="ErrorToken-fold-content"><label for="ErrorToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-22">ErrorToken</a> <a href="#name-TokenType">TokenType</a> = 0</label><span id='ErrorToken-fold-content-docs' class="fold-docs">
		ErrorToken means that an error occurred during tokenization.

</span></div><div class="anchor value-res" id="name-RawNode">	<input type='checkbox' class="fold" id="RawNode-fold-content"><label for="RawNode-fold-content">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-25">RawNode</a> <a href="#name-NodeType">NodeType</a> = 6</label><span id='RawNode-fold-content-docs' class="fold-docs">
		RawNode nodes are not returned by the parser, but can be part of the
		Node tree passed to func Render to insert raw HTML (without escaping).
		If so, this package makes no guarantee that the rendered HTML is secure
		(from e.g. Cross Site Scripting attacks) or well-formed.

</span></div><div class="anchor value-res" id="name-SelfClosingTagToken">	<input type='checkbox' class="fold" id="SelfClosingTagToken-fold-content"><label for="SelfClosingTagToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-30">SelfClosingTagToken</a> <a href="#name-TokenType">TokenType</a> = 4</label><span id='SelfClosingTagToken-fold-content-docs' class="fold-docs">
		A SelfClosingTagToken tag looks like &lt;br/&gt;.

</span></div><div class="anchor value-res" id="name-StartTagToken">	<input type='checkbox' class="fold" id="StartTagToken-fold-content"><label for="StartTagToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-26">StartTagToken</a> <a href="#name-TokenType">TokenType</a> = 2</label><span id='StartTagToken-fold-content-docs' class="fold-docs">
		A StartTagToken looks like &lt;a&gt;.

</span></div><div class="anchor value-res" id="name-TextNode">	<span class="nodocs">const <a href="../../../../src/golang.org/x/net/html/node.go.html#line-16">TextNode</a> <a href="#name-NodeType">NodeType</a> = 1</span></div><div class="anchor value-res" id="name-TextToken">	<input type='checkbox' class="fold" id="TextToken-fold-content"><label for="TextToken-fold-content">const <a href="../../../../src/golang.org/x/net/html/token.go.html#line-24">TextToken</a> <a href="#name-TokenType">TokenType</a> = 1</label><span id='TextToken-fold-content-docs' class="fold-docs">
		TextToken means a text node.

</span></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.4.1</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>