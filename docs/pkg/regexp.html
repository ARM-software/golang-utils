<!DOCTYPE html>
<!--
-- Copyright (C) 2020-2022 Arm Limited or its affiliates and Contributors. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
-->
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: regexp</title>
<link href="../css/light-v0.4.1.css" rel="stylesheet">
<script src="../jvs/golds-v0.4.1.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>regexp</b></span>

<span class="title">Import Path</span>
	<a href="../index.html#pkg-regexp">regexp</a><i> (on <a href="https://pkg.go.dev/regexp" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../dep/regexp.html">9 packages</a>, and imported by <a href="../dep/regexp.html#imported-by">14 packages</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">      <a href="../src/regexp/backtrack.go.html">backtrack.go</a></span>
	<span class="nodocs">      <a href="../src/regexp/exec.go.html">exec.go</a></span>
	<span class="nodocs">      <a href="../src/regexp/onepass.go.html">onepass.go</a></span>
	<input type='checkbox' checked class="fold" id="file-3-fold-content"><label for="file-3-fold-content">   <a href="../src/regexp/regexp.go.html#doc">#d</a> <a href="../src/regexp/regexp.go.html">regexp.go</a></label><span id='file-3-fold-content-items' class="fold-items">
		Package regexp implements regular expression search.

		The syntax of the regular expressions accepted is the same
		general syntax used by Perl, Python, and other languages.
		More precisely, it is the syntax accepted by RE2 and described at
		https://golang.org/s/re2syntax, except for \C.
		For an overview of the syntax, run
		  go doc regexp/syntax

		The regexp implementation provided by this package is
		guaranteed to run in time linear in the size of the input.
		(This is a property not guaranteed by most open source
		implementations of regular expressions.) For more information
		about this property, see
		https://swtch.com/~rsc/regexp/regexp1.html
		or any book about automata theory.

		All characters are UTF-8-encoded code points.

		There are 16 methods of Regexp that match a regular expression and identify
		the matched text. Their names are matched by this regular expression:

		Find(All)?(String)?(Submatch)?(Index)?

		If 'All' is present, the routine matches successive non-overlapping
		matches of the entire expression. Empty matches abutting a preceding
		match are ignored. The return value is a slice containing the successive
		return values of the corresponding non-'All' routine. These routines take
		an extra integer argument, n. If n &gt;= 0, the function returns at most n
		matches/submatches; otherwise, it returns all of them.

		If 'String' is present, the argument is a string; otherwise it is a slice
		of bytes; return values are adjusted as appropriate.

		If 'Submatch' is present, the return value is a slice identifying the
		successive submatches of the expression. Submatches are matches of
		parenthesized subexpressions (also known as capturing groups) within the
		regular expression, numbered from left to right in order of opening
		parenthesis. Submatch 0 is the match of the entire expression, submatch 1
		the match of the first parenthesized subexpression, and so on.

		If 'Index' is present, matches and submatches are identified by byte index
		pairs within the input string: result[2*n:2*n+1] identifies the indexes of
		the nth submatch. The pair for n==0 identifies the match of the entire
		expression. If 'Index' is not present, the match is identified by the text
		of the match/submatch. If an index is negative or text is nil, it means that
		subexpression did not match any string in the input. For 'String' versions
		an empty string means either no match or an empty match.

		There is also a subset of the methods that can be applied to text read
		from a RuneReader:

		MatchReader, FindReaderIndex, FindReaderSubmatchIndex

		This set may grow. Note that regular expression matches may need to
		examine text beyond the text returned by a match, so the methods that
		match text from a RuneReader may read arbitrarily far into the input
		before returning.

		(There are a few other methods that do not match this pattern.)</span></div>
<div id="examples"><span class="title">Code Examples</span>

	<input type='checkbox' class="fold" id="example-0-fold-content"><label for="example-0-fold-content"></label><span id='example-0-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			// Compile the expression once, usually at init time.
			// Use raw strings to avoid having to quote the backslashes.
			var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
		
			fmt.Println(validID.MatchString("adam[23]"))
			fmt.Println(validID.MatchString("eve[7]"))
			fmt.Println(validID.MatchString("Job[48]"))
			fmt.Println(validID.MatchString("snakey"))
		}
</span>
	<input type='checkbox' class="fold" id="example-1-fold-content"><label for="example-1-fold-content">Match</label><span id='example-1-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			matched, err := regexp.Match(`foo.*`, []byte(`seafood`))
			fmt.Println(matched, err)
			matched, err = regexp.Match(`bar.*`, []byte(`seafood`))
			fmt.Println(matched, err)
			matched, err = regexp.Match(`a(b`, []byte(`seafood`))
			fmt.Println(matched, err)
		
		}
</span>
	<input type='checkbox' class="fold" id="example-2-fold-content"><label for="example-2-fold-content">MatchString</label><span id='example-2-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			matched, err := regexp.MatchString(`foo.*`, "seafood")
			fmt.Println(matched, err)
			matched, err = regexp.MatchString(`bar.*`, "seafood")
			fmt.Println(matched, err)
			matched, err = regexp.MatchString(`a(b`, "seafood")
			fmt.Println(matched, err)
		}
</span>
	<input type='checkbox' class="fold" id="example-3-fold-content"><label for="example-3-fold-content">QuoteMeta</label><span id='example-3-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			fmt.Println(regexp.QuoteMeta(`Escaping symbols like: .+*?()|[]{}^$`))
		}
</span>
	<input type='checkbox' class="fold" id="example-4-fold-content"><label for="example-4-fold-content">Regexp_Expand</label><span id='example-4-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		
			# another comment line
			option3: value3
		`)
		
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			// Template to convert "key: value" to "key=value" by
			// referencing the values captured by the regex pattern.
			template := []byte("$key=$value\n")
		
			result := []byte{}
		
			// For each match of the regex in the content.
			for _, submatches := range pattern.FindAllSubmatchIndex(content, -1) {
				// Apply the captured submatches to the template and append the output
				// to the result.
				result = pattern.Expand(result, template, content, submatches)
			}
			fmt.Println(string(result))
		}
</span>
	<input type='checkbox' class="fold" id="example-5-fold-content"><label for="example-5-fold-content">Regexp_ExpandString</label><span id='example-5-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := `
			# comment line
			option1: value1
			option2: value2
		
			# another comment line
			option3: value3
		`
		
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			// Template to convert "key: value" to "key=value" by
			// referencing the values captured by the regex pattern.
			template := "$key=$value\n"
		
			result := []byte{}
		
			// For each match of the regex in the content.
			for _, submatches := range pattern.FindAllStringSubmatchIndex(content, -1) {
				// Apply the captured submatches to the template and append the output
				// to the result.
				result = pattern.ExpandString(result, template, content, submatches)
			}
			fmt.Println(string(result))
		}
</span>
	<input type='checkbox' class="fold" id="example-6-fold-content"><label for="example-6-fold-content">Regexp_Find</label><span id='example-6-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.Find([]byte(`seafood fool`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-7-fold-content"><label for="example-7-fold-content">Regexp_FindAll</label><span id='example-7-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.FindAll([]byte(`seafood fool`), -1))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-8-fold-content"><label for="example-8-fold-content">Regexp_FindAllIndex</label><span id='example-8-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte("London")
			re := regexp.MustCompile(`o.`)
			fmt.Println(re.FindAllIndex(content, 1))
			fmt.Println(re.FindAllIndex(content, -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-9-fold-content"><label for="example-9-fold-content">Regexp_FindAllString</label><span id='example-9-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a.`)
			fmt.Println(re.FindAllString("paranormal", -1))
			fmt.Println(re.FindAllString("paranormal", 2))
			fmt.Println(re.FindAllString("graal", -1))
			fmt.Println(re.FindAllString("none", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-10-fold-content"><label for="example-10-fold-content">Regexp_FindAllStringSubmatch</label><span id='example-10-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-axb-", -1))
			fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-ab-", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-11-fold-content"><label for="example-11-fold-content">Regexp_FindAllStringSubmatchIndex</label><span id='example-11-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			// Indices:
			//    01234567   012345678
			//    -ab-axb-   -axxb-ab-
			fmt.Println(re.FindAllStringSubmatchIndex("-ab-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-axxb-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-ab-axb-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-axxb-ab-", -1))
			fmt.Println(re.FindAllStringSubmatchIndex("-foo-", -1))
		}
</span>
	<input type='checkbox' class="fold" id="example-12-fold-content"><label for="example-12-fold-content">Regexp_FindAllSubmatch</label><span id='example-12-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo(.?)`)
			fmt.Printf("%q\n", re.FindAllSubmatch([]byte(`seafood fool`), -1))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-13-fold-content"><label for="example-13-fold-content">Regexp_FindAllSubmatchIndex</label><span id='example-13-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		`)
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
			allIndexes := pattern.FindAllSubmatchIndex(content, -1)
			for _, loc := range allIndexes {
				fmt.Println(loc)
				fmt.Println(string(content[loc[0]:loc[1]]))
				fmt.Println(string(content[loc[2]:loc[3]]))
				fmt.Println(string(content[loc[4]:loc[5]]))
			}
		}
</span>
	<input type='checkbox' class="fold" id="example-14-fold-content"><label for="example-14-fold-content">Regexp_FindIndex</label><span id='example-14-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			content := []byte(`
			# comment line
			option1: value1
			option2: value2
		`)
			// Regex pattern captures "key: value" pair from the content.
			pattern := regexp.MustCompile(`(?m)(?P&lt;key&gt;\w+):\s+(?P&lt;value&gt;\w+)$`)
		
			loc := pattern.FindIndex(content)
			fmt.Println(loc)
			fmt.Println(string(content[loc[0]:loc[1]]))
		}
</span>
	<input type='checkbox' class="fold" id="example-15-fold-content"><label for="example-15-fold-content">Regexp_FindString</label><span id='example-15-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Printf("%q\n", re.FindString("seafood fool"))
			fmt.Printf("%q\n", re.FindString("meat"))
		}
</span>
	<input type='checkbox' class="fold" id="example-16-fold-content"><label for="example-16-fold-content">Regexp_FindStringIndex</label><span id='example-16-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`ab?`)
			fmt.Println(re.FindStringIndex("tablett"))
			fmt.Println(re.FindStringIndex("foo") == nil)
		}
</span>
	<input type='checkbox' class="fold" id="example-17-fold-content"><label for="example-17-fold-content">Regexp_FindStringSubmatch</label><span id='example-17-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b(y|z)c`)
			fmt.Printf("%q\n", re.FindStringSubmatch("-axxxbyc-"))
			fmt.Printf("%q\n", re.FindStringSubmatch("-abzc-"))
		}
</span>
	<input type='checkbox' class="fold" id="example-18-fold-content"><label for="example-18-fold-content">Regexp_FindSubmatch</label><span id='example-18-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo(.?)`)
			fmt.Printf("%q\n", re.FindSubmatch([]byte(`seafood fool`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-19-fold-content"><label for="example-19-fold-content">Regexp_FindSubmatchIndex</label><span id='example-19-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			// Indices:
			//    01234567   012345678
			//    -ab-axb-   -axxb-ab-
			fmt.Println(re.FindSubmatchIndex([]byte("-ab-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-axxb-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-ab-axb-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-axxb-ab-")))
			fmt.Println(re.FindSubmatchIndex([]byte("-foo-")))
		}
</span>
	<input type='checkbox' class="fold" id="example-20-fold-content"><label for="example-20-fold-content">Regexp_Longest</label><span id='example-20-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(|b)`)
			fmt.Println(re.FindString("ab"))
			re.Longest()
			fmt.Println(re.FindString("ab"))
		}
</span>
	<input type='checkbox' class="fold" id="example-21-fold-content"><label for="example-21-fold-content">Regexp_Match</label><span id='example-21-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`foo.?`)
			fmt.Println(re.Match([]byte(`seafood fool`)))
			fmt.Println(re.Match([]byte(`something else`)))
		
		}
</span>
	<input type='checkbox' class="fold" id="example-22-fold-content"><label for="example-22-fold-content">Regexp_MatchString</label><span id='example-22-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(gopher){2}`)
			fmt.Println(re.MatchString("gopher"))
			fmt.Println(re.MatchString("gophergopher"))
			fmt.Println(re.MatchString("gophergophergopher"))
		}
</span>
	<input type='checkbox' class="fold" id="example-23-fold-content"><label for="example-23-fold-content">Regexp_NumSubexp</label><span id='example-23-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re0 := regexp.MustCompile(`a.`)
			fmt.Printf("%d\n", re0.NumSubexp())
		
			re := regexp.MustCompile(`(.*)((a)b)(.*)a`)
			fmt.Println(re.NumSubexp())
		}
</span>
	<input type='checkbox' class="fold" id="example-24-fold-content"><label for="example-24-fold-content">Regexp_ReplaceAll</label><span id='example-24-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("T")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("$1")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("$1W")))
			fmt.Printf("%s\n", re.ReplaceAll([]byte("-ab-axxb-"), []byte("${1}W")))
		}
</span>
	<input type='checkbox' class="fold" id="example-25-fold-content"><label for="example-25-fold-content">Regexp_ReplaceAllLiteralString</label><span id='example-25-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "T"))
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "$1"))
			fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "${1}"))
		}
</span>
	<input type='checkbox' class="fold" id="example-26-fold-content"><label for="example-26-fold-content">Regexp_ReplaceAllString</label><span id='example-26-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`a(x*)b`)
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "T"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1W"))
			fmt.Println(re.ReplaceAllString("-ab-axxb-", "${1}W"))
		}
</span>
	<input type='checkbox' class="fold" id="example-27-fold-content"><label for="example-27-fold-content">Regexp_ReplaceAllStringFunc</label><span id='example-27-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
			"strings"
		)
		
		func main() {
			re := regexp.MustCompile(`[^aeiou]`)
			fmt.Println(re.ReplaceAllStringFunc("seafood fool", strings.ToUpper))
		}
</span>
	<input type='checkbox' class="fold" id="example-28-fold-content"><label for="example-28-fold-content">Regexp_Split</label><span id='example-28-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			a := regexp.MustCompile(`a`)
			fmt.Println(a.Split("banana", -1))
			fmt.Println(a.Split("banana", 0))
			fmt.Println(a.Split("banana", 1))
			fmt.Println(a.Split("banana", 2))
			zp := regexp.MustCompile(`z+`)
			fmt.Println(zp.Split("pizza", -1))
			fmt.Println(zp.Split("pizza", 0))
			fmt.Println(zp.Split("pizza", 1))
			fmt.Println(zp.Split("pizza", 2))
		}
</span>
	<input type='checkbox' class="fold" id="example-29-fold-content"><label for="example-29-fold-content">Regexp_SubexpIndex</label><span id='example-29-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
			fmt.Println(re.MatchString("Alan Turing"))
			matches := re.FindStringSubmatch("Alan Turing")
			lastIndex := re.SubexpIndex("last")
			fmt.Printf("last =&gt; %d\n", lastIndex)
			fmt.Println(matches[lastIndex])
		}
</span>
	<input type='checkbox' class="fold" id="example-30-fold-content"><label for="example-30-fold-content">Regexp_SubexpNames</label><span id='example-30-fold-content-items' class="fold-items">
		package main
		
		import (
			"fmt"
			"regexp"
		)
		
		func main() {
			re := regexp.MustCompile(`(?P&lt;first&gt;[a-zA-Z]+) (?P&lt;last&gt;[a-zA-Z]+)`)
			fmt.Println(re.MatchString("Alan Turing"))
			fmt.Printf("%q\n", re.SubexpNames())
			reversed := fmt.Sprintf("${%s} ${%s}", re.SubexpNames()[2], re.SubexpNames()[1])
			fmt.Println(reversed)
			fmt.Println(re.ReplaceAllString("Alan Turing", reversed))
		}
</span>
</div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (only one)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Regexp" data-popularity="2380">	<input type='checkbox' class="fold" id="Regexp-fold-content"><label for="Regexp-fold-content"> type <a href="../src/regexp/regexp.go.html#line-82">Regexp</a> <i>(struct)</i></label><span id='Regexp-fold-content-docs' class="fold-docs">
		Regexp is the representation of a compiled regular expression.
		A Regexp is safe for concurrent use by multiple goroutines,
		except for configuration methods, such as Longest.

		<input type='checkbox' class="fold" id="Regexp-fold-methods"><label for="Regexp-fold-methods">Methods (<i>total 37</i>)</label><span id='Regexp-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Copy"><label for="Regexp-fold-method-Copy">(*T) <a href="../src/regexp/regexp.go.html#line-117">Copy</a>() *<b>Regexp</b></label><span id='Regexp-fold-method-Copy-docs' class="fold-docs">
				Copy returns a new Regexp object copied from re.
				Calling Longest on one copy does not affect another.

				Deprecated: In earlier releases, when using a Regexp in multiple goroutines,
				giving each goroutine its own copy helped to avoid lock contention.
				As of Go 1.12, using Copy is no longer necessary to avoid lock contention.
				Copy may still be appropriate if the reason for its use is to make
				two copies with different Longest settings.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Expand"><label for="Regexp-fold-method-Expand">(*T) <a href="../src/regexp/regexp.go.html#line-912">Expand</a>(dst []<a href="builtin.html#name-byte">byte</a>, template []<a href="builtin.html#name-byte">byte</a>, src []<a href="builtin.html#name-byte">byte</a>, match []<a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-Expand-docs' class="fold-docs">
				Expand appends template to dst and returns the result; during the
				append, Expand replaces variables in the template with corresponding
				matches drawn from src. The match slice should have been returned by
				FindSubmatchIndex.

				In the template, a variable is denoted by a substring of the form
				$name or ${name}, where name is a non-empty sequence of letters,
				digits, and underscores. A purely numeric name like $1 refers to
				the submatch with the corresponding index; other names refer to
				capturing parentheses named with the (?P&lt;name&gt;...) syntax. A
				reference to an out of range or unmatched index or a name that is not
				present in the regular expression is replaced with an empty slice.

				In the $name form, name is taken to be as long as possible: $1x is
				equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.

				To insert a literal $ in the output, use $$ in the template.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ExpandString"><label for="Regexp-fold-method-ExpandString">(*T) <a href="../src/regexp/regexp.go.html#line-919">ExpandString</a>(dst []<a href="builtin.html#name-byte">byte</a>, template <a href="builtin.html#name-string">string</a>, src <a href="builtin.html#name-string">string</a>, match []<a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ExpandString-docs' class="fold-docs">
				ExpandString is like Expand but the template and source are strings.
				It appends to and returns a byte slice in order to give the calling
				code control over allocation.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Find"><label for="Regexp-fold-method-Find">(*T) <a href="../src/regexp/regexp.go.html#line-815">Find</a>(b []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-Find-docs' class="fold-docs">
				Find returns a slice holding the text of the leftmost match in b of the regular expression.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAll"><label for="Regexp-fold-method-FindAll">(*T) <a href="../src/regexp/regexp.go.html#line-1076">FindAll</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindAll-docs' class="fold-docs">
				FindAll is the 'All' version of Find; it returns a slice of all successive
				matches of the expression, as defined by the 'All' description in the
				package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllIndex"><label for="Regexp-fold-method-FindAllIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1094">FindAllIndex</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllIndex-docs' class="fold-docs">
				FindAllIndex is the 'All' version of FindIndex; it returns a slice of all
				successive matches of the expression, as defined by the 'All' description
				in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllString"><label for="Regexp-fold-method-FindAllString">(*T) <a href="../src/regexp/regexp.go.html#line-1112">FindAllString</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindAllString-docs' class="fold-docs">
				FindAllString is the 'All' version of FindString; it returns a slice of all
				successive matches of the expression, as defined by the 'All' description
				in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringIndex"><label for="Regexp-fold-method-FindAllStringIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1130">FindAllStringIndex</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllStringIndex-docs' class="fold-docs">
				FindAllStringIndex is the 'All' version of FindStringIndex; it returns a
				slice of all successive matches of the expression, as defined by the 'All'
				description in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringSubmatch"><label for="Regexp-fold-method-FindAllStringSubmatch">(*T) <a href="../src/regexp/regexp.go.html#line-1190">FindAllStringSubmatch</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindAllStringSubmatch-docs' class="fold-docs">
				FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it
				returns a slice of all successive matches of the expression, as defined by
				the 'All' description in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllStringSubmatchIndex"><label for="Regexp-fold-method-FindAllStringSubmatchIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1215">FindAllStringSubmatchIndex</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllStringSubmatchIndex-docs' class="fold-docs">
				FindAllStringSubmatchIndex is the 'All' version of
				FindStringSubmatchIndex; it returns a slice of all successive matches of
				the expression, as defined by the 'All' description in the package
				comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllSubmatch"><label for="Regexp-fold-method-FindAllSubmatch">(*T) <a href="../src/regexp/regexp.go.html#line-1148">FindAllSubmatch</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindAllSubmatch-docs' class="fold-docs">
				FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice
				of all successive matches of the expression, as defined by the 'All'
				description in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindAllSubmatchIndex"><label for="Regexp-fold-method-FindAllSubmatchIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1172">FindAllSubmatchIndex</a>(b []<a href="builtin.html#name-byte">byte</a>, n <a href="builtin.html#name-int">int</a>) [][]<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindAllSubmatchIndex-docs' class="fold-docs">
				FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns
				a slice of all successive matches of the expression, as defined by the
				'All' description in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindIndex"><label for="Regexp-fold-method-FindIndex">(*T) <a href="../src/regexp/regexp.go.html#line-828">FindIndex</a>(b []<a href="builtin.html#name-byte">byte</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindIndex-docs' class="fold-docs">
				FindIndex returns a two-element slice of integers defining the location of
				the leftmost match in b of the regular expression. The match itself is at
				b[loc[0]:loc[1]].
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindReaderIndex"><label for="Regexp-fold-method-FindReaderIndex">(*T) <a href="../src/regexp/regexp.go.html#line-867">FindReaderIndex</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindReaderIndex-docs' class="fold-docs">
				FindReaderIndex returns a two-element slice of integers defining the
				location of the leftmost match of the regular expression in text read from
				the RuneReader. The match text was found in the input stream at
				byte offset loc[0] through loc[1]-1.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindReaderSubmatchIndex"><label for="Regexp-fold-method-FindReaderSubmatchIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1066">FindReaderSubmatchIndex</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindReaderSubmatchIndex-docs' class="fold-docs">
				FindReaderSubmatchIndex returns a slice holding the index pairs
				identifying the leftmost match of the regular expression of text read by
				the RuneReader, and the matches, if any, of its subexpressions, as defined
				by the 'Submatch' and 'Index' descriptions in the package comment. A
				return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindString"><label for="Regexp-fold-method-FindString">(*T) <a href="../src/regexp/regexp.go.html#line-841">FindString</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindString-docs' class="fold-docs">
				FindString returns a string holding the text of the leftmost match in s of the regular
				expression. If there is no match, the return value is an empty string,
				but it will also be empty if the regular expression successfully matches
				an empty string. Use FindStringIndex or FindStringSubmatch if it is
				necessary to distinguish these cases.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringIndex"><label for="Regexp-fold-method-FindStringIndex">(*T) <a href="../src/regexp/regexp.go.html#line-854">FindStringIndex</a>(s <a href="builtin.html#name-string">string</a>) (loc []<a href="builtin.html#name-int">int</a>)</label><span id='Regexp-fold-method-FindStringIndex-docs' class="fold-docs">
				FindStringIndex returns a two-element slice of integers defining the
				location of the leftmost match in s of the regular expression. The match
				itself is at s[loc[0]:loc[1]].
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringSubmatch"><label for="Regexp-fold-method-FindStringSubmatch">(*T) <a href="../src/regexp/regexp.go.html#line-1037">FindStringSubmatch</a>(s <a href="builtin.html#name-string">string</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-FindStringSubmatch-docs' class="fold-docs">
				FindStringSubmatch returns a slice of strings holding the text of the
				leftmost match of the regular expression in s and the matches, if any, of
				its subexpressions, as defined by the 'Submatch' description in the
				package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindStringSubmatchIndex"><label for="Regexp-fold-method-FindStringSubmatchIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1057">FindStringSubmatchIndex</a>(s <a href="builtin.html#name-string">string</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindStringSubmatchIndex-docs' class="fold-docs">
				FindStringSubmatchIndex returns a slice holding the index pairs
				identifying the leftmost match of the regular expression in s and the
				matches, if any, of its subexpressions, as defined by the 'Submatch' and
				'Index' descriptions in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindSubmatch"><label for="Regexp-fold-method-FindSubmatch">(*T) <a href="../src/regexp/regexp.go.html#line-880">FindSubmatch</a>(b []<a href="builtin.html#name-byte">byte</a>) [][]<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-FindSubmatch-docs' class="fold-docs">
				FindSubmatch returns a slice of slices holding the text of the leftmost
				match of the regular expression in b and the matches, if any, of its
				subexpressions, as defined by the 'Submatch' descriptions in the package
				comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-FindSubmatchIndex"><label for="Regexp-fold-method-FindSubmatchIndex">(*T) <a href="../src/regexp/regexp.go.html#line-1028">FindSubmatchIndex</a>(b []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-FindSubmatchIndex-docs' class="fold-docs">
				FindSubmatchIndex returns a slice holding the index pairs identifying the
				leftmost match of the regular expression in b and the matches, if any, of
				its subexpressions, as defined by the 'Submatch' and 'Index' descriptions
				in the package comment.
				A return value of nil indicates no match.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-LiteralPrefix"><label for="Regexp-fold-method-LiteralPrefix">(*T) <a href="../src/regexp/regexp.go.html#line-512">LiteralPrefix</a>() (prefix <a href="builtin.html#name-string">string</a>, complete <a href="builtin.html#name-bool">bool</a>)</label><span id='Regexp-fold-method-LiteralPrefix-docs' class="fold-docs">
				LiteralPrefix returns a literal string that must begin any match
				of the regular expression re. It returns the boolean true if the
				literal string comprises the entire regular expression.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Longest"><label for="Regexp-fold-method-Longest">(*T) <a href="../src/regexp/regexp.go.html#line-165">Longest</a>()</label><span id='Regexp-fold-method-Longest-docs' class="fold-docs">
				Longest makes future searches prefer the leftmost-longest match.
				That is, when matching against text, the regexp returns a match that
				begins as early as possible in the input (leftmost), and among those
				it chooses a match that is as long as possible.
				This method modifies the Regexp and may not be called concurrently
				with any other methods.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Match"><label for="Regexp-fold-method-Match">(*T) <a href="../src/regexp/regexp.go.html#line-530">Match</a>(b []<a href="builtin.html#name-byte">byte</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-Match-docs' class="fold-docs">
				Match reports whether the byte slice b
				contains any match of the regular expression re.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-MatchReader"><label for="Regexp-fold-method-MatchReader">(*T) <a href="../src/regexp/regexp.go.html#line-518">MatchReader</a>(r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-MatchReader-docs' class="fold-docs">
				MatchReader reports whether the text returned by the RuneReader
				contains any match of the regular expression re.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-MatchString"><label for="Regexp-fold-method-MatchString">(*T) <a href="../src/regexp/regexp.go.html#line-524">MatchString</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-bool">bool</a></label><span id='Regexp-fold-method-MatchString-docs' class="fold-docs">
				MatchString reports whether the string s
				contains any match of the regular expression re.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-NumSubexp"><label for="Regexp-fold-method-NumSubexp">(*T) <a href="../src/regexp/regexp.go.html#line-335">NumSubexp</a>() <a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-NumSubexp-docs' class="fold-docs">
				NumSubexp returns the number of parenthesized subexpressions in this Regexp.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAll"><label for="Regexp-fold-method-ReplaceAll">(*T) <a href="../src/regexp/regexp.go.html#line-669">ReplaceAll</a>(src, repl []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAll-docs' class="fold-docs">
				ReplaceAll returns a copy of src, replacing matches of the Regexp
				with the replacement text repl. Inside repl, $ signs are interpreted as
				in Expand, so for instance $1 represents the text of the first submatch.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllFunc"><label for="Regexp-fold-method-ReplaceAllFunc">(*T) <a href="../src/regexp/regexp.go.html#line-697">ReplaceAllFunc</a>(src []<a href="builtin.html#name-byte">byte</a>, repl func([]<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAllFunc-docs' class="fold-docs">
				ReplaceAllFunc returns a copy of src in which all matches of the
				Regexp have been replaced by the return value of function repl applied
				to the matched byte slice. The replacement returned by repl is substituted
				directly, without using Expand.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllLiteral"><label for="Regexp-fold-method-ReplaceAllLiteral">(*T) <a href="../src/regexp/regexp.go.html#line-687">ReplaceAllLiteral</a>(src, repl []<a href="builtin.html#name-byte">byte</a>) []<a href="builtin.html#name-byte">byte</a></label><span id='Regexp-fold-method-ReplaceAllLiteral-docs' class="fold-docs">
				ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp
				with the replacement bytes repl. The replacement repl is substituted directly,
				without using Expand.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllLiteralString"><label for="Regexp-fold-method-ReplaceAllLiteralString">(*T) <a href="../src/regexp/regexp.go.html#line-584">ReplaceAllLiteralString</a>(src, repl <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllLiteralString-docs' class="fold-docs">
				ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp
				with the replacement string repl. The replacement repl is substituted directly,
				without using Expand.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllString"><label for="Regexp-fold-method-ReplaceAllString">(*T) <a href="../src/regexp/regexp.go.html#line-570">ReplaceAllString</a>(src, repl <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllString-docs' class="fold-docs">
				ReplaceAllString returns a copy of src, replacing matches of the Regexp
				with the replacement string repl. Inside repl, $ signs are interpreted as
				in Expand, so for instance $1 represents the text of the first submatch.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-ReplaceAllStringFunc"><label for="Regexp-fold-method-ReplaceAllStringFunc">(*T) <a href="../src/regexp/regexp.go.html#line-594">ReplaceAllStringFunc</a>(src <a href="builtin.html#name-string">string</a>, repl func(<a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-ReplaceAllStringFunc-docs' class="fold-docs">
				ReplaceAllStringFunc returns a copy of src in which all matches of the
				Regexp have been replaced by the return value of function repl applied
				to the matched substring. The replacement returned by repl is substituted
				directly, without using Expand.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-Split"><label for="Regexp-fold-method-Split">(*T) <a href="../src/regexp/regexp.go.html#line-1244">Split</a>(s <a href="builtin.html#name-string">string</a>, n <a href="builtin.html#name-int">int</a>) []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-Split-docs' class="fold-docs">
				Split slices s into substrings separated by the expression and returns a slice of
				the substrings between those expression matches.

				The slice returned by this method consists of all the substrings of s
				not contained in the slice returned by FindAllString. When called on an expression
				that contains no metacharacters, it is equivalent to strings.SplitN.

				Example:
				  s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
				  // s: ["", "b", "b", "c", "cadaaae"]

				The count determines the number of substrings to return:
				  n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
				  n == 0: the result is nil (zero substrings)
				  n &lt; 0: all substrings
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-String"><label for="Regexp-fold-method-String">(*T) <a href="../src/regexp/regexp.go.html#line-105">String</a>() <a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-String-docs' class="fold-docs">
				String returns the source text used to compile the regular expression.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-SubexpIndex"><label for="Regexp-fold-method-SubexpIndex">(*T) <a href="../src/regexp/regexp.go.html#line-355">SubexpIndex</a>(name <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-int">int</a></label><span id='Regexp-fold-method-SubexpIndex-docs' class="fold-docs">
				SubexpIndex returns the index of the first subexpression with the given name,
				or -1 if there is no subexpression with that name.

				Note that multiple subexpressions can be written using the same name, as in
				(?P&lt;bob&gt;a+)(?P&lt;bob&gt;b+), which declares two subexpressions named "bob".
				In this case, SubexpIndex returns the index of the leftmost such subexpression
				in the regular expression.
</span></span><span>
			<input type='checkbox' class="fold" id="Regexp-fold-method-SubexpNames"><label for="Regexp-fold-method-SubexpNames">(*T) <a href="../src/regexp/regexp.go.html#line-344">SubexpNames</a>() []<a href="builtin.html#name-string">string</a></label><span id='Regexp-fold-method-SubexpNames-docs' class="fold-docs">
				SubexpNames returns the names of the parenthesized subexpressions
				in this Regexp. The name for the first sub-expression is names[1],
				so that if m is a match slice, the name for m[i] is SubexpNames()[i].
				Since the Regexp as a whole cannot be named, names[0] is always
				the empty string. The slice should not be modified.
</span></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-impls"><label for="Regexp-fold-impls">Implements (<i>at least one exported</i>)</label><span id='Regexp-fold-impls-items' class="fold-items"><span>
			*T : fmt.<a href="fmt.html#name-Stringer">Stringer</a></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-results"><label for="Regexp-fold-results">As Outputs Of (<i>at least 5</i>)</label><span id='Regexp-fold-results-items' class="fold-items"><span>
			func <a href="#name-Compile">Compile</a>(expr <a href="builtin.html#name-string">string</a>) (*<b>Regexp</b>, <a href="builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-CompilePOSIX">CompilePOSIX</a>(expr <a href="builtin.html#name-string">string</a>) (*<b>Regexp</b>, <a href="builtin.html#name-error">error</a>)</span><span>
			func <a href="#name-MustCompile">MustCompile</a>(str <a href="builtin.html#name-string">string</a>) *<b>Regexp</b></span><span>
			func <a href="#name-MustCompilePOSIX">MustCompilePOSIX</a>(str <a href="builtin.html#name-string">string</a>) *<b>Regexp</b></span><span>
			func (*Regexp).<a href="../src/regexp/regexp.go.html#line-117">Copy</a>() *<b>Regexp</b></span></span>
		<input type='checkbox' class="fold" id="Regexp-fold-params"><label for="Regexp-fold-params">As Inputs Of (<i>at least 3</i>)</label><span id='Regexp-fold-params-items' class="fold-items"><span>
			func github.com/go-ozzo/ozzo-validation/v4.<a href="github.com/go-ozzo/ozzo-validation/v4.html#name-Match">Match</a>(re *<b>Regexp</b>) <a href="github.com/go-ozzo/ozzo-validation/v4.html">validation</a>.<a href="github.com/go-ozzo/ozzo-validation/v4.html#name-MatchRule">MatchRule</a></span><span>
			func github.com/magiconair/properties.(*<a href="github.com/magiconair/properties.html#name-Properties">Properties</a>).<a href="../src/github.com/magiconair/properties/properties.go.html#line-463">FilterRegexp</a>(re *<b>Regexp</b>) *<a href="github.com/magiconair/properties.html">properties</a>.<a href="github.com/magiconair/properties.html#name-Properties">Properties</a></span><span>
			func github.com/spf13/afero.<a href="github.com/spf13/afero.html#name-NewRegexpFs">NewRegexpFs</a>(source <a href="github.com/spf13/afero.html">afero</a>.<a href="github.com/spf13/afero.html#name-Fs">Fs</a>, re *<b>Regexp</b>) <a href="github.com/spf13/afero.html">afero</a>.<a href="github.com/spf13/afero.html#name-Fs">Fs</a></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 8)</i></span></span>

<div class="anchor value-res" id="name-Compile">	<input type='checkbox' class="fold" id="Compile-fold-content"><label for="Compile-fold-content"> func <a href="../src/regexp/regexp.go.html#line-132">Compile</a>(expr <a href="builtin.html#name-string">string</a>) (*<a href="#name-Regexp">Regexp</a>, <a href="builtin.html#name-error">error</a>)</label><span id='Compile-fold-content-docs' class="fold-docs">
		Compile parses a regular expression and returns, if successful,
		a Regexp object that can be used to match against text.

		When matching against text, the regexp returns a match that
		begins as early as possible in the input (leftmost), and among those
		it chooses the one that a backtracking search would have found first.
		This so-called leftmost-first matching is the same semantics
		that Perl, Python, and other implementations use, although this
		package implements it without the expense of backtracking.
		For POSIX leftmost-longest matching, see CompilePOSIX.

</span></div><div class="anchor value-res" id="name-CompilePOSIX">	<input type='checkbox' class="fold" id="CompilePOSIX-fold-content"><label for="CompilePOSIX-fold-content"> func <a href="../src/regexp/regexp.go.html#line-155">CompilePOSIX</a>(expr <a href="builtin.html#name-string">string</a>) (*<a href="#name-Regexp">Regexp</a>, <a href="builtin.html#name-error">error</a>)</label><span id='CompilePOSIX-fold-content-docs' class="fold-docs">
		CompilePOSIX is like Compile but restricts the regular expression
		to POSIX ERE (egrep) syntax and changes the match semantics to
		leftmost-longest.

		That is, when matching against text, the regexp returns a match that
		begins as early as possible in the input (leftmost), and among those
		it chooses a match that is as long as possible.
		This so-called leftmost-longest matching is the same semantics
		that early regular expression implementations used and that POSIX
		specifies.

		However, there can be multiple leftmost-longest matches, with different
		submatch choices, and here this package diverges from POSIX.
		Among the possible leftmost-longest matches, this package chooses
		the one that a backtracking search would have found first, while POSIX
		specifies that the match be chosen to maximize the length of the first
		subexpression, then the second, and so on from left to right.
		The POSIX rule is computationally prohibitive and not even well-defined.
		See https://swtch.com/~rsc/regexp/regexp2.html#posix for details.

</span></div><div class="anchor value-res" id="name-Match">	<input type='checkbox' class="fold" id="Match-fold-content"><label for="Match-fold-content"> func <a href="../src/regexp/regexp.go.html#line-559">Match</a>(pattern <a href="builtin.html#name-string">string</a>, b []<a href="builtin.html#name-byte">byte</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='Match-fold-content-docs' class="fold-docs">
		Match reports whether the byte slice b
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.

</span></div><div class="anchor value-res" id="name-MatchReader">	<input type='checkbox' class="fold" id="MatchReader-fold-content"><label for="MatchReader-fold-content"> func <a href="../src/regexp/regexp.go.html#line-537">MatchReader</a>(pattern <a href="builtin.html#name-string">string</a>, r <a href="io.html">io</a>.<a href="io.html#name-RuneReader">RuneReader</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='MatchReader-fold-content-docs' class="fold-docs">
		MatchReader reports whether the text returned by the RuneReader
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.

</span></div><div class="anchor value-res" id="name-MatchString">	<input type='checkbox' class="fold" id="MatchString-fold-content"><label for="MatchString-fold-content"> func <a href="../src/regexp/regexp.go.html#line-548">MatchString</a>(pattern <a href="builtin.html#name-string">string</a>, s <a href="builtin.html#name-string">string</a>) (matched <a href="builtin.html#name-bool">bool</a>, err <a href="builtin.html#name-error">error</a>)</label><span id='MatchString-fold-content-docs' class="fold-docs">
		MatchString reports whether the string s
		contains any match of the regular expression pattern.
		More complicated queries need to use Compile and the full Regexp interface.

</span></div><div class="anchor value-res" id="name-MustCompile">	<input type='checkbox' class="fold" id="MustCompile-fold-content"><label for="MustCompile-fold-content"> func <a href="../src/regexp/regexp.go.html#line-308">MustCompile</a>(str <a href="builtin.html#name-string">string</a>) *<a href="#name-Regexp">Regexp</a></label><span id='MustCompile-fold-content-docs' class="fold-docs">
		MustCompile is like Compile but panics if the expression cannot be parsed.
		It simplifies safe initialization of global variables holding compiled regular
		expressions.

</span></div><div class="anchor value-res" id="name-MustCompilePOSIX">	<input type='checkbox' class="fold" id="MustCompilePOSIX-fold-content"><label for="MustCompilePOSIX-fold-content"> func <a href="../src/regexp/regexp.go.html#line-319">MustCompilePOSIX</a>(str <a href="builtin.html#name-string">string</a>) *<a href="#name-Regexp">Regexp</a></label><span id='MustCompilePOSIX-fold-content-docs' class="fold-docs">
		MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.
		It simplifies safe initialization of global variables holding compiled regular
		expressions.

</span></div><div class="anchor value-res" id="name-QuoteMeta">	<input type='checkbox' class="fold" id="QuoteMeta-fold-content"><label for="QuoteMeta-fold-content"> func <a href="../src/regexp/regexp.go.html#line-720">QuoteMeta</a>(s <a href="builtin.html#name-string">string</a>) <a href="builtin.html#name-string">string</a></label><span id='QuoteMeta-fold-content-docs' class="fold-docs">
		QuoteMeta returns a string that escapes all regular expression metacharacters
		inside the argument text; the returned string is a regular expression matching
		the literal text.

</span></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.4.1</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>